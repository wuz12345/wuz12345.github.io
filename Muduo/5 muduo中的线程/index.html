
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="wuzhuang">
      
      
        <meta name="author" content="wuzhuang">
      
      
        <link rel="canonical" href="https://wuz12345.github.io/Muduo/5%20muduo%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.2.16">
    
    
      
        <title>5 muduo中的线程 - wuzhuang</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.1c3799f8.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cc9b2e1e.min.css">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="wuzhuang" class="md-header__button md-logo" aria-label="wuzhuang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            wuzhuang
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              5 muduo中的线程
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/wuz12345/mynote/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="wuzhuang" class="md-nav__button md-logo" aria-label="wuzhuang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    wuzhuang
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/wuz12345/mynote/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        简介
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../about/" class="md-nav__link">
        关于
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          LearnGo
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LearnGo" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          LearnGo
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnGo/Read/" class="md-nav__link">
        简介
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          LearnC++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LearnC++" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          LearnC++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1" type="checkbox" id="__nav_4_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1">
          模板和泛型编程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="模板和泛型编程" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          模板和泛型编程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/READ/" class="md-nav__link">
        简介
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E7%B1%BB%E6%A8%A1%E6%9D%BF/" class="md-nav__link">
        类模板
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E6%97%A0%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/" class="md-nav__link">
        非类型模板参数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" class="md-nav__link">
        可变类型模板
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/" class="md-nav__link">
        拷贝赋值
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_3" type="checkbox" id="__nav_4_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_3">
          Effiective Modern C++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Effiective Modern C++" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_3">
          <span class="md-nav__icon md-icon"></span>
          Effiective Modern C++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item01/" class="md-nav__link">
        item1
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item02/" class="md-nav__link">
        item2
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item07/" class="md-nav__link">
        item7
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/" class="md-nav__link">
        左值与右值
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          GDB
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="GDB" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          GDB
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../GDB/gdb%E8%B0%83%E8%AF%95/" class="md-nav__link">
        GDB调试
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          LeetCode刷题
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LeetCode刷题" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          LeetCode刷题
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LeetCode%20%E5%88%B7%E9%A2%98/%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="md-nav__link">
        线性表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          webRTC
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="webRTC" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          webRTC
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../webrtc/FEC/FEC/" class="md-nav__link">
        FEC
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
  <a href="https://github.com/wuz12345/mynote/edit/master/docs/Muduo/5 muduo中的线程.md" title="Edit this page" class="md-content__button md-icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>



  <h1>5 muduo中的线程</h1>

<p>首先，介绍在多线程编程中不可缺少的同步措施&ndash;Mutex和Condition.</p>
<ul>
<li>Mutex</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cm">/***Mutex.h***/</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">MutexLock</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">MutexLock</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">holder_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">));</span><span class="c1">//MCHECK有什么作用？</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="o">~</span><span class="n">MutexLock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">holder_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// must be called when locked, i.e. for assertion</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">isLockedByThisThread</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="c1">//是否被当前线程锁住</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">holder_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">();</span><span class="c1">//防止跨线程调用</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">assertLocked</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">isLockedByThisThread</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// internal usage</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">));</span><span class="c1">//加锁</span>
<span class="w">    </span><span class="n">assignHolder</span><span class="p">();</span><span class="c1">//加锁时获得当前线程的线程号，即目前线程拥有这个锁</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">unassignHolder</span><span class="p">();</span><span class="c1">//表示目前没有线程拥有这个锁</span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">));</span><span class="c1">//去锁</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">pthread_mutex_t</span><span class="o">*</span><span class="w"> </span><span class="n">getPthreadMutex</span><span class="p">()</span><span class="w"> </span><span class="cm">/* non-const */</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Condition</span><span class="p">;</span><span class="c1">//条件变量必须持有了锁之后才能使用</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">UnassignGuard</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="c1">//这个内部类出现的莫名其妙</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">UnassignGuard</span><span class="p">(</span><span class="n">MutexLock</span><span class="o">&amp;</span><span class="w"> </span><span class="n">owner</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">owner_</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">owner_</span><span class="p">.</span><span class="n">unassignHolder</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="o">~</span><span class="n">UnassignGuard</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">owner_</span><span class="p">.</span><span class="n">assignHolder</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">MutexLock</span><span class="o">&amp;</span><span class="w"> </span><span class="n">owner_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">unassignHolder</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">holder_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">assignHolder</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">holder_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">pthread_mutex_t</span><span class="w"> </span><span class="n">mutex_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">holder_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Use as a stack variable, eg.</span>
<span class="c1">// int Foo::size() const</span>
<span class="c1">// {</span>
<span class="c1">//   MutexLockGuard lock(mutex_);</span>
<span class="c1">//   return data_.size();</span>
<span class="c1">// }</span>
<span class="c1">//该类负责管理互斥量的加锁和去锁</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MutexLockGuard</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="w"></span>
<span class="p">{</span><span class="w">   </span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">MutexLockGuard</span><span class="p">(</span><span class="n">MutexLock</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mutex</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">mutex_</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">mutex_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="o">~</span><span class="n">MutexLockGuard</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">mutex_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>

<span class="w">  </span><span class="n">MutexLock</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mutex_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<p>有四种操作互斥锁的方式：创建，销毁，加锁，解锁。在muduo中，用一个低级的资源管理类MutexLock来实现这四种操作，再用一个较高级的资源管理类MutexLockGuard来管理MutexLock，即用RAII手法对资源进行两次封装，防止资源泄漏。
两个类都具有nocopy的属性，试想对Mutex的拷贝会在多线程程序中造成什么样的结果？有至少两个线程在同一时间拥有对一份资源的使用资格，后果不可设想。
在MutexLock中有一个好玩的私有变量：holder_. 该变量在一个线程对资源加锁时，将holder_设置为使用资源线程的索引；解锁时将holder_设置为0。初始化Mutex时将holder_设置为0；销毁时检查holder_是否为0。以上四个步骤保证了Mutex在某一个时间段内能被一个线程使用。
MutexLock与Condition是友元关系，具有很强的耦合度。</p>
<ul>
<li>Condition</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cm">/***Condition.h***/</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Condition</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">Condition</span><span class="p">(</span><span class="n">MutexLock</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mutex</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">mutex_</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcond_</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="o">~</span><span class="n">Condition</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcond_</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">wait</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MutexLock</span><span class="o">::</span><span class="n">UnassignGuard</span><span class="w"> </span><span class="nf">ug</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcond_</span><span class="p">,</span><span class="w"> </span><span class="n">mutex_</span><span class="p">.</span><span class="n">getPthreadMutex</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// returns true if time out, false otherwise.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">waitForSeconds</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">seconds</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">notify</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcond_</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">notifyAll</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MCHECK</span><span class="p">(</span><span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcond_</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">MutexLock</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mutex_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pthread_cond_t</span><span class="w"> </span><span class="n">pcond_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<p>条件变量有五种操作方式：创建，销毁，等待，单一通知，全部通知。
在MutexLock中有一个内部类：UnassignGuard，该类的实例对象在Condition等待时创建，将holder_设置为0；当等待事件结束，又将holder_设置为原值。用MutexLock的析构函数检查等待事件是否发生在同一个线程中。
Condition类中有一个waitForSecond函数，用于实现pthread_cond_timewait的封装。
接下来，聊一聊主题&ndash;Thread。</p>
<ul>
<li>Thread</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cm">/***Thread.h***/</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="w">   </span><span class="c1">//禁止拷贝</span>
<span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ThreadFunc</span><span class="p">;</span><span class="c1">//仿函数对象,利用回调的方式使用线程函数</span>

<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ThreadFunc</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">string</span><span class="p">());</span><span class="c1">//普通的线程构造函数</span>
<span class="cp">#ifdef __GXX_EXPERIMENTAL_CXX0X__</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">ThreadFunc</span><span class="o">&amp;&amp;</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">string</span><span class="p">());</span><span class="c1">//移动的线程构造函数，比上面的更节省资源std::move</span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="o">~</span><span class="n">Thread</span><span class="p">();</span><span class="c1">//析构函数</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">start</span><span class="p">();</span><span class="c1">//启动线程</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">join</span><span class="p">();</span><span class="w"> </span><span class="c1">// 类似于 pthread_join()</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">started</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">started_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// pthread_t pthreadId() const { return pthreadId_; }</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="nf">tid</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">tid_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">//返回线程索引</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">name_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="c1">//返回线程名字</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">numCreated</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">numCreated_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">setDefaultName</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w">       </span><span class="n">started_</span><span class="p">;</span><span class="w">  </span><span class="c1">//是否启动</span>
<span class="w">  </span><span class="kt">bool</span><span class="w">       </span><span class="n">joined_</span><span class="p">;</span><span class="w">   </span><span class="c1">//是否终止</span>
<span class="w">  </span><span class="n">pthread_t</span><span class="w">  </span><span class="n">pthreadId_</span><span class="p">;</span><span class="w">    </span><span class="c1">//线程索引</span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">pid_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tid_</span><span class="p">;</span><span class="w">    </span><span class="c1">//持有一个强线程索引</span>
<span class="w">  </span><span class="n">ThreadFunc</span><span class="w"> </span><span class="n">func_</span><span class="p">;</span><span class="w">     </span><span class="c1">//线程主体函数</span>
<span class="w">  </span><span class="n">string</span><span class="w">     </span><span class="n">name_</span><span class="p">;</span><span class="w">     </span><span class="c1">//线程名称标号</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">AtomicInt32</span><span class="w"> </span><span class="n">numCreated_</span><span class="p">;</span><span class="w">   </span><span class="c1">//static变量在所有的线程对象中共享，为由该类产生线程排序</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<ol>
<li>在muduo的线程对象封装中，最精彩的是使用boost::function函数对象将线程函数以回调的方式传递进线程对象中。
   <code>typedef boost::function&lt;void ()&gt; ThreadFun;</code></li>
<li>在多线程情况下，避免在对象外操作指向对象的指针的情形，可以在一定程度上保证了线程安全。</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="cm">/***Thread.cc***/</span><span class="w"></span>
<span class="n">AtomicInt32</span><span class="w"> </span><span class="n">Thread</span><span class="o">::</span><span class="n">numCreated_</span><span class="p">;</span><span class="w"></span>

<span class="c1">//两种线程构造函数</span>
<span class="c1">//线程对象的可移动属性很有意思。</span>
<span class="n">Thread</span><span class="o">::</span><span class="n">Thread</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ThreadFunc</span><span class="o">&amp;</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">started_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">joined_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">pthreadId_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">tid_</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">pid_t</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span><span class="w"></span>
<span class="w">    </span><span class="n">func_</span><span class="p">(</span><span class="n">func</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">name_</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">setDefaultName</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#ifdef __GXX_EXPERIMENTAL_CXX0X__</span>
<span class="n">Thread</span><span class="o">::</span><span class="n">Thread</span><span class="p">(</span><span class="n">ThreadFunc</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">started_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">joined_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">pthreadId_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">tid_</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">pid_t</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span><span class="w"></span>
<span class="w">    </span><span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">func</span><span class="p">)),</span><span class="w"></span>
<span class="w">    </span><span class="n">name_</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">setDefaultName</span><span class="p">();</span><span class="w">     </span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#endif</span>

<span class="n">Thread</span><span class="o">::~</span><span class="n">Thread</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">started_</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">joined_</span><span class="p">)</span><span class="w">     </span><span class="c1">//将该线程设置为分离属性</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">pthread_detach</span><span class="p">(</span><span class="n">pthreadId_</span><span class="p">);</span><span class="w">     </span><span class="c1">//线程结束将自动回收资源</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Thread</span><span class="o">::</span><span class="n">setDefaultName</span><span class="p">()</span><span class="w">   </span><span class="c1">//设置线程名字，比如Thread1,Thread2等</span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numCreated_</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">name_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w">   </span>
<span class="w">    </span><span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Thread%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">name_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Thread</span><span class="o">::</span><span class="n">start</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">started_</span><span class="p">);</span><span class="w">    </span><span class="c1">//断言线程是否已经开始运行</span>
<span class="w">  </span><span class="n">started_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">      </span><span class="c1">//断言失败则设置线程开始运行的标志</span>
<span class="w">  </span><span class="c1">// FIXME: move(func_)</span>
<span class="w">  </span><span class="n">detail</span><span class="o">::</span><span class="n">ThreadData</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">detail</span><span class="o">::</span><span class="n">ThreadData</span><span class="p">(</span><span class="n">func_</span><span class="p">,</span><span class="w"> </span><span class="n">name_</span><span class="p">,</span><span class="w"> </span><span class="n">tid_</span><span class="p">);</span><span class="w">   </span><span class="c1">//获得线程运行的所需要的参数</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pthreadId_</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">detail</span><span class="o">::</span><span class="n">startThread</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">))</span><span class="c1">//线程开始运行并且线程的控制流停止再在此。</span>
<span class="w">  </span><span class="p">{</span><span class="w">     </span><span class="c1">//线程运行结束，线程自行运行结束并且自己做日志记录</span>
<span class="w">    </span><span class="n">started_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;blockDim.x: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="c1">// or no delete?</span>
<span class="w">    </span><span class="n">LOG_SYSFATAL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed in pthread_create&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">Thread</span><span class="o">::</span><span class="n">join</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">started_</span><span class="p">);</span><span class="w">     </span><span class="c1">//断言线程是否正在运行</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">joined_</span><span class="p">);</span><span class="w">     </span><span class="c1">//断言线程是否已经被终止</span>
<span class="w">  </span><span class="n">joined_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">pthread_join</span><span class="p">(</span><span class="n">pthreadId_</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w">        </span><span class="c1">//等待线程结束</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>在线程的析构函数中只设置线程的分离属性，即等待线程运行结束后自动回收线程资源，不强行终止线程。</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ThreadData</span><span class="w">  </span><span class="c1">//作为线程数据使用，将线程运行有关的数据保存到该结构体中，有点抽象回调的意思</span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">muduo</span><span class="o">::</span><span class="n">Thread</span><span class="o">::</span><span class="n">ThreadFunc</span><span class="w"> </span><span class="n">ThreadFunc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ThreadFunc</span><span class="w"> </span><span class="n">func_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">string</span><span class="w"> </span><span class="n">name_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">pid_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wkTid_</span><span class="p">;</span><span class="w">    </span><span class="c1">//使用弱引用保存线程标号</span>

<span class="w">  </span><span class="n">ThreadData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ThreadFunc</span><span class="o">&amp;</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">pid_t</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">tid</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">func_</span><span class="p">(</span><span class="n">func</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">wkTid_</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">runInThread</span><span class="p">()</span><span class="w">    </span><span class="c1">//核心函数</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">muduo</span><span class="o">::</span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">();</span><span class="w">    </span><span class="c1">//得到当前的线程标志</span>

<span class="w">    </span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">pid_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wkTid_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w">    </span><span class="c1">//判断保存在ThreadData中的线程是否存在</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptid</span><span class="p">)</span><span class="w">    </span><span class="c1">//如果存在，ptid释放之前指向的线程标识</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="n">ptid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">ptid</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">muduo</span><span class="o">::</span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">t_threadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name_</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;muduoThread&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">name_</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span><span class="w"> </span><span class="c1">//获得当前线程名称</span>
<span class="w">    </span><span class="o">::</span><span class="n">prctl</span><span class="p">(</span><span class="n">PR_SET_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">muduo</span><span class="o">::</span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">t_threadName</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">try</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">func_</span><span class="p">();</span><span class="w"> </span><span class="c1">//运行线程函数</span>
<span class="w">      </span><span class="n">muduo</span><span class="o">::</span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">t_threadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;finished&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w">    </span><span class="c1">//异常捕捉部分</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">muduo</span><span class="o">::</span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">t_threadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;crashed&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;exception caught in Thread %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name_</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;reason: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;stack trace: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">stackTrace</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">muduo</span><span class="o">::</span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">t_threadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;crashed&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;exception caught in Thread %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name_</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;reason: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">muduo</span><span class="o">::</span><span class="n">CurrentThread</span><span class="o">::</span><span class="n">t_threadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;crashed&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;unknown exception caught in Thread %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name_</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// rethrow</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">startThread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">)</span><span class="w">    </span><span class="c1">//这个函数最有意思</span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ThreadData</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ThreadData</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w">    </span><span class="c1">//强行转化为ThreadData</span>
<span class="w">  </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">runInThread</span><span class="p">();</span><span class="w">    </span><span class="c1">//线程跑起来</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>将线程中的若干数据保存到ThreadData中，然后将ThreadData作为传递给<code>pthread_create(...,void* arg)</code>中的最后一个数据参数传递给<code>void Thread(void* )</code>标准的线程启动函数。然后在标准的线程启动函数内将<code>void* arg</code>强行转化为ThreadData，然后使用ThreadData启动线程。
在使用muduo的接口时，使用bind将线程运行函数再打包，然后传递进Thread.
最后，向大家介绍muduo库中对于线程池的封装的理解。</p>
<ol>
<li>最重要的想法就是线程池将线程看为自己可执行的最小并且可随时增加的单位。</li>
<li>整个线程池对象维持两个任务队列，threads_表示目前正在运行中的线程池，queue_表示位于存储队列中的等待线程。</li>
<li>thread_在运行的过程中使用while循环+条件变量判断当前的活动线程池中是否有空位，以及新的等待线程进入线程池。</li>
<li>线程池从一开始就确定了自己将要运行的线程数目，不能在后面的运行中更改。</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="cm">/***ThreadPool.h***/</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">ThreadPool</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Task</span><span class="p">;</span><span class="c1">//将线程池中的线程作为可替换的任务，以线程为基本单位放在线程池中运行</span>

<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">ThreadPool</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nameArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="s">&quot;ThreadPool&quot;</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="o">~</span><span class="n">ThreadPool</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Must be called before start().</span>
<span class="w">  </span><span class="c1">// 设置线程池运行的最大的负载以及线程池中将要运行的线程</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">setMaxQueueSize</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">maxSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">maxQueueSize_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maxSize</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="c1">//</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">setThreadInitCallback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Task</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cb</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">threadInitCallback_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cb</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numThreads</span><span class="p">);</span><span class="c1">//启动一定数量的线程</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">stop</span><span class="p">();</span><span class="c1">//线程池运算停止</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">name_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">queueSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="c1">//返回正在排队等待的线程任务</span>

<span class="w">  </span><span class="c1">// Could block if maxQueueSize &gt; 0</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Task</span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">);</span><span class="c1">//将一个想要运行的线程放入线程池的任务队列</span>
<span class="cp">#ifdef __GXX_EXPERIMENTAL_CXX0X__</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">Task</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">);</span><span class="c1">//C++11的移动方法，用于节省资源</span>
<span class="cp">#endif</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">isFull</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="c1">//判断线程队列是否已经满了</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">runInThread</span><span class="p">();</span><span class="c1">//真正让线程跑起来的函数</span>
<span class="w">  </span><span class="n">Task</span><span class="w"> </span><span class="nf">take</span><span class="p">();</span><span class="c1">//获得任务队列的首个线程</span>

<span class="w">  </span><span class="k">mutable</span><span class="w"> </span><span class="n">MutexLock</span><span class="w"> </span><span class="n">mutex_</span><span class="p">;</span><span class="c1">//互斥锁</span>
<span class="w">  </span><span class="n">Condition</span><span class="w"> </span><span class="n">notEmpty_</span><span class="p">;</span><span class="c1">//条件变量</span>
<span class="w">  </span><span class="n">Condition</span><span class="w"> </span><span class="n">notFull_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">string</span><span class="w"> </span><span class="n">name_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Task</span><span class="w"> </span><span class="n">threadInitCallback_</span><span class="p">;</span><span class="c1">//线程池中执行的线程对象</span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">ptr_vector</span><span class="o">&lt;</span><span class="n">muduo</span><span class="o">::</span><span class="n">Thread</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threads_</span><span class="p">;</span><span class="c1">//线程池</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue_</span><span class="p">;</span><span class="c1">//排队执行的线程对象队列</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">maxQueueSize_</span><span class="p">;</span><span class="c1">//队列的最大数</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">running_</span><span class="p">;</span><span class="c1">//是否已经启动</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<ol>
<li>每一个加入线程池的线程都带有一个while循环，保证线程等待队列中的线程不会等待太久。即所有将加入线程池的线程都会进入线程等待队列接受检查。</li>
<li>start()：线程池启动函数保证在调用时启动一定数量的线程。</li>
<li>stop()：保证所有的正在运行的线程停止</li>
<li>queueSize()：返回此时线程等待队列中的个数，用于判断线程等待队列是否为空</li>
<li>run()：如果线程池为空，直接跑传入的线程。如果线程池等待队列满了，则当前控制流（线程）在notFull_上等待；否则将传入的线程加入线程等待队列，并且使用条件变量notEmpty_通知一条阻塞在该条件变量上的控制流（线程）。</li>
<li>take()：如果当前线程等待队列为空并且线程池正在跑，则控制流（线程）阻塞在notEmpty_条件变量上。当条件变量被激活时（有线程对象加入呆线程等待队列），判断是否可以从线程等待队列中拿出一个线程对象，如果可以，则将使用条件变量notFull_通知run()中阻塞在&ndash;想加入队列但是队列没有空余位置的变量上。</li>
<li>isFull()：返回在线程等待队列中的个数，用于判断是否可以将想要运行的线程放到线程等待队列中。</li>
<li>runInThread()：如果线程启动函数不为空，则在此将线程的控制流交给用于初始化线程池的线程对象。当此线程对象运行结束的时候，并且此时的线程池还在运行，则线程池离开初始化模式，进入线程池的循环线程补充模式。这种模式控制着线程池中的线程数量：当有新的线程对象进入线程池，则当前的线程控制流交给将要执行的线程对象。也就是说线程池中的线程对象要么主动结束自己的‘life’，然后由线程池的线程补充模式决定将要进入线程池运行的线程对象。然后在后面的take()中使用条件变量完成新的线程进入线程池的同步。</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="cm">/***ThreadPool.cc***/</span><span class="w"></span>
<span class="n">ThreadPool</span><span class="o">::</span><span class="n">ThreadPool</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nameArg</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">mutex_</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="n">notEmpty_</span><span class="p">(</span><span class="n">mutex_</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">notFull_</span><span class="p">(</span><span class="n">mutex_</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">name_</span><span class="p">(</span><span class="n">nameArg</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">maxQueueSize_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">running_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">ThreadPool</span><span class="o">::~</span><span class="n">ThreadPool</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">running_</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">stop</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">start</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numThreads</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">threads_</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span><span class="c1">//首次启动，断言线程池为空</span>
<span class="w">  </span><span class="n">running_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">threads_</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">numThreads</span><span class="p">);</span><span class="c1">//预分配空间，且分配的空间不可变。</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numThreads</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">id</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">snprintf</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">threads_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">muduo</span><span class="o">::</span><span class="n">Thread</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">runInThread</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">),</span><span class="w"> </span><span class="n">name_</span><span class="o">+</span><span class="n">id</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">threads_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">();</span><span class="c1">//直接启动线程</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">numThreads</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">threadInitCallback_</span><span class="p">)</span><span class="c1">//只启动一条线程</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">threadInitCallback_</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">stop</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">MutexLockGuard</span><span class="w"> </span><span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">running_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">notEmpty_</span><span class="p">.</span><span class="n">notifyAll</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">for_each</span><span class="p">(</span><span class="n">threads_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">           </span><span class="n">threads_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">           </span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">muduo</span><span class="o">::</span><span class="n">Thread</span><span class="o">::</span><span class="n">join</span><span class="p">,</span><span class="w"> </span><span class="n">_1</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">size_t</span><span class="w"> </span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">queueSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">MutexLockGuard</span><span class="w"> </span><span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">queue_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Task</span><span class="o">&amp;</span><span class="w"> </span><span class="n">task</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threads_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="c1">//如果线程池为空，直接跑这条线程</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">task</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MutexLockGuard</span><span class="w"> </span><span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">isFull</span><span class="p">())</span><span class="c1">//如果线程池满了，在notfull条件变量上等待</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">notFull_</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isFull</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">queue_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="c1">//现在线程池中有空位了</span>
<span class="w">    </span><span class="n">notEmpty_</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span><span class="c1">//notempty条件变量通知信息</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#ifdef __GXX_EXPERIMENTAL_CXX0X__</span>
<span class="kt">void</span><span class="w"> </span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">Task</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">task</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threads_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">task</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MutexLockGuard</span><span class="w"> </span><span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">isFull</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">notFull_</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isFull</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">queue_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">notEmpty_</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="n">ThreadPool</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">take</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">MutexLockGuard</span><span class="w"> </span><span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// always use a while-loop, due to spurious wakeup</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">running_</span><span class="p">)</span><span class="c1">//如果线程队列为空并且线程池正在跑</span>
<span class="w">  </span><span class="p">{</span><span class="c1">//在notempty条件变量上等待</span>
<span class="w">    </span><span class="n">notEmpty_</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="c1">//当前线程停下来等待，当队列不为空了继续跑</span>
<span class="w">  </span><span class="p">}</span><span class="c1">//然后获得新任务</span>
<span class="w">  </span><span class="n">Task</span><span class="w"> </span><span class="n">task</span><span class="p">;</span><span class="c1">//创建一个新的任务</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queue_</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="c1">//获得队列中的头任务</span>
<span class="w">    </span><span class="n">queue_</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span><span class="c1">//弹出队列中的头任务</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maxQueueSize_</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="c1">//如果队列最大长度大于0</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">notFull_</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span><span class="c1">//通知线程可以跑了</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">task</span><span class="p">;</span><span class="c1">//返回任务</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">isFull</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="p">{</span><span class="c1">//用来判断线程队列是否已经</span>
<span class="w">  </span><span class="n">mutex_</span><span class="p">.</span><span class="n">assertLocked</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">maxQueueSize_</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">queue_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">maxQueueSize_</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">runInThread</span><span class="p">()</span><span class="c1">//生成一个threadFunc对象</span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">try</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadInitCallback_</span><span class="p">)</span><span class="c1">//如果线程启动函数不为空，直接启动</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">threadInitCallback_</span><span class="p">();</span><span class="c1">//此处开启新的线程，程序的运行流程在此停止；当线程运行完成则进入下面的while循环</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">running_</span><span class="p">)</span><span class="c1">//该循环保证当上面的线程运行完成或者没有初始化线程，则进入线程池的循环模式</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">Task</span><span class="w"> </span><span class="nf">task</span><span class="p">(</span><span class="n">take</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">task</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w">   </span><span class="c1">//异常捕捉过程</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;exception caught in ThreadPool %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name_</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;reason: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;stack trace: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">stackTrace</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;exception caught in ThreadPool %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name_</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;reason: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;unknown exception caught in ThreadPool %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name_</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// rethrow</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</code></pre></div>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2a1c317c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.3a4b43e5.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
    
  </body>
</html>