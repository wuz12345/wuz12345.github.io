
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="wuzhuang">
      
      
        <meta name="author" content="wuzhuang">
      
      
        <link rel="canonical" href="https://wuz12345.github.io/golang/concurrency-in-go/concurrency_in_go/">
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.2.16">
    
    
      
        <title>Concurrency in go - wuzhuang</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.1c3799f8.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cc9b2e1e.min.css">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1-an-introduction-to-concurrency" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="wuzhuang" class="md-header__button md-logo" aria-label="wuzhuang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            wuzhuang
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Concurrency in go
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/wuz12345/mynote/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="wuzhuang" class="md-nav__button md-logo" aria-label="wuzhuang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    wuzhuang
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/wuz12345/mynote/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        简介
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../about/" class="md-nav__link">
        关于
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          LearnGo
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LearnGo" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          LearnGo
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnGo/Read/" class="md-nav__link">
        简介
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          LearnC++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LearnC++" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          LearnC++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1" type="checkbox" id="__nav_4_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1">
          模板和泛型编程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="模板和泛型编程" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          模板和泛型编程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/READ/" class="md-nav__link">
        简介
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E7%B1%BB%E6%A8%A1%E6%9D%BF/" class="md-nav__link">
        类模板
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E6%97%A0%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/" class="md-nav__link">
        非类型模板参数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" class="md-nav__link">
        可变类型模板
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/" class="md-nav__link">
        拷贝赋值
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_3" type="checkbox" id="__nav_4_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_3">
          Effiective Modern C++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Effiective Modern C++" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_3">
          <span class="md-nav__icon md-icon"></span>
          Effiective Modern C++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/Effective%20C%2B%2B/Item01/" class="md-nav__link">
        item1
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/Effective%20C%2B%2B/Item02/" class="md-nav__link">
        item2
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/Effective%20C%2B%2B/Item07/" class="md-nav__link">
        item7
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LearnC%2B%2B/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/" class="md-nav__link">
        左值与右值
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          LeetCode刷题
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LeetCode刷题" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          LeetCode刷题
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../LeetCode%20%E5%88%B7%E9%A2%98/%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="md-nav__link">
        线性表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          webRTC
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="webRTC" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          webRTC
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../webrtc/FEC/FEC/" class="md-nav__link">
        FEC
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#deadlocks-livelocks-and-starvation" class="md-nav__link">
    Deadlocks, Livelocks, and Starvation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#determining-concurrency-safety" class="md-nav__link">
    Determining Concurrency Safety
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#simplicity-in-the-face-of-complexity" class="md-nav__link">
    Simplicity in the Face of Complexity
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
  <a href="https://github.com/wuz12345/mynote/edit/master/docs/golang/concurrency-in-go/concurrency_in_go.md" title="Edit this page" class="md-content__button md-icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>



<p>《Concurrency In Go》</p>
<h1 id="1-an-introduction-to-concurrency">1 An Introduction to Concurrency<a class="headerlink" href="#1-an-introduction-to-concurrency" title="Permanent link">&para;</a></h1>
<p>critical section（临界区）：for a section of your program needs exclusive access to a shared resource.</p>
<h3 id="deadlocks-livelocks-and-starvation">Deadlocks, Livelocks, and Starvation<a class="headerlink" href="#deadlocks-livelocks-and-starvation" title="Permanent link">&para;</a></h3>
<p>Deadlocks conditions:</p>
<ul>
<li>Mutual Exclusion</li>
<li>Wait For Condition</li>
<li>No Preemption</li>
<li>Circular Wait</li>
</ul>
<p>Livelocks: 活锁。想象两个人迎面走来，一个人向一边转，然后另一个人也同方向转，如此循环一直僵持谁都过不去。</p>
<p>Starvation: 饥饿 ，一个并发的进程无法获取所有需要工作的资源。一个贪心的进程阻止其他进程获取执行资源。</p>
<h3 id="determining-concurrency-safety">Determining Concurrency Safety<a class="headerlink" href="#determining-concurrency-safety" title="Permanent link">&para;</a></h3>
<ul>
<li>who is responsible for the Concurrency?</li>
<li>how is the problem space mapped onto concurrency primitives?</li>
<li>who is responsible for the synchronization?</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span><span class="w"> </span><span class="nx">CalculatePi</span><span class="p">(</span><span class="nx">begin</span><span class="p">,</span><span class="nx">end</span><span class="w"> </span><span class="kt">int64</span><span class="p">,</span><span class="w"> </span><span class="nx">pi</span><span class="w"> </span><span class="o">*</span><span class="nx">Pi</span><span class="p">)</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="nx">CalculatePi</span><span class="p">(</span><span class="nx">begin</span><span class="p">,</span><span class="nx">end</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int64</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="nx">CalculatePi</span><span class="p">(</span><span class="nx">begin</span><span class="p">,</span><span class="nx">end</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kt">uint</span><span class="w"></span>
</code></pre></div>
<h3 id="simplicity-in-the-face-of-complexity">Simplicity in the Face of Complexity<a class="headerlink" href="#simplicity-in-the-face-of-complexity" title="Permanent link">&para;</a></h3>
<h1 id="2-modeling-your-code-communicating-sequential-processes">2 Modeling Your Code: Communicating Sequential Processes<a class="headerlink" href="#2-modeling-your-code-communicating-sequential-processes" title="Permanent link">&para;</a></h1>
<h3 id="concurrency-vs-parallelism">Concurrency vs Parallelism<a class="headerlink" href="#concurrency-vs-parallelism" title="Permanent link">&para;</a></h3>
<p>Concurrency is a property of the code; parallelism is a property of the runnning programm.</p>
<h3 id="what-is-csp">What Is CSP?<a class="headerlink" href="#what-is-csp" title="Permanent link">&para;</a></h3>
<h3 id="gos-philosophy-on-concurrency">Go&rsquo;s Philosophy on Concurrency<a class="headerlink" href="#gos-philosophy-on-concurrency" title="Permanent link">&para;</a></h3>
<p>CSP primitives or Memory access synchronizations.
Use whichever is most expressive and/or most simple.</p>
<p><img alt="" src="../decision_tree.png" /></p>
<p>Aim for simplicity, use channels when possible, and treat goroutines like a free resource.</p>
<h1 id="3-gos-concurrency-building-blocks">3 Go&rsquo;s Concurrency Building Blocks<a class="headerlink" href="#3-gos-concurrency-building-blocks" title="Permanent link">&para;</a></h1>
<p>Coroutines are simply concurrent subroutines(functions, clousures or methods in Go) that are nonpreemptive.(非抢占式)</p>
<p>Go follows a model of concurrency called the fork-join model.</p>
<p><img alt="" src="../join_point.png" /></p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="w"></span>

<span class="nx">sayHello</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="k">go</span><span class="w"> </span><span class="nx">sayHello</span><span class="p">()</span><span class="w"></span>
<span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">join</span><span class="w"> </span><span class="nx">point</span><span class="err">，</span><span class="nx">等</span><span class="w"> </span><span class="nx">child</span><span class="w"> </span><span class="nx">执行完毕</span><span class="w"></span>
</code></pre></div>
<h3 id="the-sync-package">The sync Package<a class="headerlink" href="#the-sync-package" title="Permanent link">&para;</a></h3>
<p>The sync package contains the concurrency primitives that are most useful for low-level memory access synchronization.</p>
<h4 id="waitgroup">WaitGroup<a class="headerlink" href="#waitgroup" title="Permanent link">&para;</a></h4>
<p>Wait for a set of concurrent operations to complete when you either don&rsquo;t care about the result of the concurrent
operations , or you have other means of collecting their results.</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;sync&quot;</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;time&quot;</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="w"></span>

<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">// 注意 Add 必须在外边而不是在 go func() 函数体里边</span><span class="w"></span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;1st goroutine sleeping...&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}()</span><span class="w"></span>

<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;2nd goroutine sleeping...&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}()</span><span class="w"></span>

<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;All goroutines complete&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="mutex-and-rwmutex">Mutex and RWMutex<a class="headerlink" href="#mutex-and-rwmutex" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">// Mutex demo</span><span class="w"></span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;sync&quot;</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">lock</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="w"></span>

<span class="w">    </span><span class="nx">incr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">lock</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">lock</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="nx">count</span><span class="o">++</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Incr: %d\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">count</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nx">decr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">lock</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">lock</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="nx">count</span><span class="o">--</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Decr: %d\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">count</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">arithmetic</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">defer</span><span class="w"> </span><span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="nx">incr</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">defer</span><span class="w"> </span><span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="nx">decr</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Done&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>RWMutex: 适合读多写少场景。可以获取多个读锁，除非锁用来持有写入。</p>
<h4 id="cond">Cond<a class="headerlink" href="#cond" title="Permanent link">&para;</a></h4>
<p>A rendezvous point for goroutine waiting for or announcing the occurrence of an event.</p>
<p><div class="highlight"><pre><span></span><code>for conditoinTrue() == false{
    time.Sleep(1*time.Millisecond) //sleep多久是个问题，太久效率低下，太快消耗 cpu
}
</code></pre></div>
use Cond, we cloud write like this:</p>
<p><div class="highlight"><pre><span></span><code>c := sync.NewCond(&amp;sync.Mutex{})
c.L.Lock()
for conditoinTrue() == false {
    c.Wait() // blocking call, will suspend
}
c.L.UnLock()
</code></pre></div>
考虑有一个固定长度为2的队列，10个 items 想要 push 进去。
只要有空间我们就希望入队，被尽早通知。</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    c := sync.NewCond(&amp;sync.Mutex{})
    queue := make([]interface{}, 0, 10)

    removeFromQueue := func(delay time.Duration) {
        time.Sleep(delay)
        c.L.Lock() // enter the critical section
        queue = queue[1:] //simulate dequeuing an item
        fmt.Println(&quot;removed from queue&quot;)
        c.L.Unlock() // exit critical section
        c.Signal() // let a goroutine waiting on the condition know that something has occured
    }

    for i := 0; i &lt; 10; i++ {
        c.L.Lock() //进入临界区, critical section
        for len(queue) == 2 {
            c.Wait() //will suspend the main goroutine until a signal on the condition has been sent
        }
        fmt.Println(&quot;Adding to queue&quot;)
        queue = append(queue, struct{}{})
        go removeFromQueue(1 * time.Second)
        c.L.Unlock() //exit critical section
    }
}
</code></pre></div>
<h4 id="once">Once<a class="headerlink" href="#once" title="Permanent link">&para;</a></h4>
<p>only one call to &ldquo;Do&rdquo;, even on different goroutines.</p>
<p><div class="highlight"><pre><span></span><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    var count int

    increment := func() {
        count++
    }

    var once sync.Once
    var wg sync.WaitGroup
    wg.Add(100)
    for i := 0; i &lt; 100; i++ {
        go func() {
            defer wg.Done()
            once.Do(increment)
        }()
    }
    wg.Wait()
    fmt.Printf(&quot;count is %d\n&quot;, count) //1
}
</code></pre></div>
NOTES: sync.Once only counts the number of times Do is Called, not
how many times unique functions passed into Do are called.</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    var count int
    increment := func() { count++ }
    decremet := func() { count-- }

    var once sync.Once
    once.Do(increment)
    once.Do(decremet)
    fmt.Printf(&quot;count is %d\n&quot;, count) //1
}
</code></pre></div>
<h4 id="pool">Pool(并发安全对象池)<a class="headerlink" href="#pool" title="Permanent link">&para;</a></h4>
<p>Pool is a concurrent-safe implementation of the object pool pattern.</p>
<div class="highlight"><pre><span></span><code>myPool := &amp;sync.Pool{
    New: func() interface{}{
        fmt.Println(&quot;Creating new instance.&quot;)
        return struct{}{}
    },
}

myPool.Get()
instance:=myPool.Get()
myPool.Put(instance)
myPool.Get()
</code></pre></div>
<p>Another common situation where a Pool is useful is for warming a cache of pre-allocated
objects for operations that must run as quickly as possible.</p>
<p>When working with sync.Pool:</p>
<ul>
<li>give it a New member variable that is thread-safe when called</li>
<li>when receive an instance from Get,make no assumptions regarding the state of the object you receive back</li>
<li>Make sure to call Put when you&rsquo;re finished with the object you pulled out of the pool.(with defer)</li>
<li>Objects in the pool must be roughly uniform in makeup</li>
</ul>
<h3 id="channels">Channels<a class="headerlink" href="#channels" title="Permanent link">&para;</a></h3>
<p>Go will implicitly convert bidirectional channels to unidirectional channels when needed.</p>
<div class="highlight"><pre><span></span><code>var receiveChan &lt;- chan interface{}
var sendChan chan &lt;- interface{}
dataStream := make(chan interface{})
//valid statements, 双向的可以赋值给单向的
receiveChan = dataStream
sendChan = dataStream
</code></pre></div>
<p>Unbufferd channel in Go are said to be blocking.</p>
<div class="highlight"><pre><span></span><code>val, ok := &lt;-stringStream // ok 判断还有没有值，从一个已经 closed 的 channel 依然会获取默认值
</code></pre></div>
<p>The second return value is a way for a read operation to indicate whether the read off the channel
was a value generated by a write elsewhere in the process, or a default value generated from a closed channel.</p>
<p>We can use &ldquo;for range&rdquo; iter channel, it will automatically break the loop when cahnnel is closed.</p>
<p>Buffred channels, even if no reads are performed on the channel, a goroutine can still perform n writes.
You can treat buffered channels are an inmemory FIFO queue for concurrent processes to communicate over.</p>
<p><img alt="" src="../channel1.png" />
<img alt="" src="../channel2.png" /></p>
<p>The first thing we should do to put channels in the right context is to assign channel ownership.</p>
<ul>
<li>Instaniate the channel.</li>
<li>Perform writes, os pass ownership to another goroutine.</li>
<li>Close the channel</li>
<li>Ecapsulate the previous three things in this list and expose them via a reader channel.</li>
</ul>
<p>As a consumer of a channel, I only have to worry about two things.</p>
<ul>
<li>Knowing when a channel is closed (use val, ok)</li>
<li>Responsibly handling blocking for any reason</li>
</ul>
<div class="highlight"><pre><span></span><code>// keep the scope of channel ownership small
func main() {

    chanOwner := func() &lt;-chan int {
        resultStream := make(chan int, 5)
        go func() {
            defer close(resultStream)
            for i := 0; i &lt;= 5; i++ {
                resultStream &lt;- i
            }
        }()
        return resultStream // will implicityly converted to read-only for consumers
    }

    resultStream := chanOwner()
    for result := range resultStream {
        fmt.Printf(&quot;received : %d\n&quot;, result)
    }

    fmt.Println(&quot;Done receiving!&quot;)
}
</code></pre></div>
<h3 id="the-select-statement">The select Statement<a class="headerlink" href="#the-select-statement" title="Permanent link">&para;</a></h3>
<p>The select statement is the glue that binds channels together,
it can help safely bring channels together with concepts like cancellations, timeouts, waiting, and default values.</p>
<div class="highlight"><pre><span></span><code>func main() {
    // a bit like switch
    var c1, c2 &lt;-chan interface{}   // receive only chan
    var c3 chan&lt;- interface{}  // send only chan
    // all channels reads and writes are considered simultaneously to see if any of them are ready
    // populated or closed channels in the case of reads, and channels that are not at capacity in the case of writes
    // if none of the channels are ready, the entire select statement blocks
    select {
    case &lt;-c1:
        // do something
    case &lt;-c2:
        // do something
    case c3 &lt;- struct{}{}:
        // do something
    }
}
</code></pre></div>
<ul>
<li>
<p>What happens when multiple channels have something to read?</p>
</li>
<li>
<p>random select, each has an equal  chance of being selected as all the others</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>func main() {
    c1 := make(chan interface{})
    close(c1)
    c2 := make(chan interface{})
    close(c2)
    var c1Count, c2Count int
    for i := 1000; i &gt;= 0; i-- {
        select {
        case &lt;-c1:
            c1Count++
        case &lt;-c2:
            c2Count++
        }
    }
    fmt.Printf(&quot;c1: %d\n, c2: %d\n&quot;, c1Count, c2Count)
}
</code></pre></div>
<ul>
<li>
<p>What if there are never any channels that become ready?</p>
</li>
<li>
<p>you may want to timeout</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>func main() {
    var c &lt;-chan int
    select {
    case &lt;-c:
    case &lt;-time.After(1 * time.Second):
        fmt.Println(&quot;Time out&quot;)
    }
}
</code></pre></div>
<ul>
<li>
<p>what if we want to do something but no channels are currently ready?</p>
</li>
<li>
<p>use default</p>
</li>
<li>this allows a goroutine to make progress on work while waiting for another goroutine to report a result</li>
</ul>
<div class="highlight"><pre><span></span><code>func main() {
    start := time.Now()
    var c1, c2 &lt;-chan int
    select {
    case &lt;-c1:
    case &lt;-c2:
    default:
        fmt.Printf(&quot;In default after %v\n\n&quot;, time.Since(start))
    }
}
</code></pre></div>
<div class="highlight"><pre><span></span><code>func main() {
    done := make(chan interface{})
    go func() {
        time.Sleep(5 * time.Second)
        close(done)
    }()
    workCounter := 0
loop:
    for {
        select {
        case &lt;-done:
            break loop
        default:
        }
        // simulate work
        workCounter++
        time.Sleep(1 * time.Second)
    }
    fmt.Printf(&quot;Achieved %v cycles of work before signalled to stop.\n&quot;, workCounter)
}
</code></pre></div>
<h6 id="empty-select">empty select<a class="headerlink" href="#empty-select" title="Permanent link">&para;</a></h6>
<p><code>seelct {}</code> will block forever.</p>
<h3 id="the-gomaxprocs-lever">The GOMAXPROCS lever<a class="headerlink" href="#the-gomaxprocs-lever" title="Permanent link">&para;</a></h3>
<p>this function controls the number of OS threads that will host so-called &ldquo;work queues&rdquo;</p>
<h1 id="4-concurrency-patterns-in-go">4. Concurrency Patterns in Go<a class="headerlink" href="#4-concurrency-patterns-in-go" title="Permanent link">&para;</a></h1>
<h3 id="confinement">Confinement(限制)<a class="headerlink" href="#confinement" title="Permanent link">&para;</a></h3>
<p>When working with concurrent code</p>
<ul>
<li>Synchronization primitives for sharing memory (sync.Mutex)</li>
<li>Synchronization via Communicating (channels)</li>
<li>Immutable Data (copy of values)</li>
<li>Data protected by confinement (ad hoc and lexical)</li>
</ul>
<div class="highlight"><pre><span></span><code>func main() {
    // confines the write aspect of this channel to prevent other goroutines from writing to it
    // 限制向 channel 写数据到一个 func 里
    chanOnwer := func() &lt;-chan int {
        results := make(chan int, 5)
        go func() {
            defer close(results)
            for i := 0; i &lt;= 5; i++ {
                results &lt;- i
            }
        }()
        return results
    }

    consumer := func(results &lt;-chan int) {
        for result := range results {
            fmt.Printf(&quot;Received : %d\n&quot;, result)
        }
        fmt.Println(&quot;Done receiving!&quot;)
    }

    results := chanOnwer()
    consumer(results)
}
</code></pre></div>
<h3 id="the-for-select-loop">The for-select Loop<a class="headerlink" href="#the-for-select-loop" title="Permanent link">&para;</a></h3>
<ul>
<li>Sending iteration variables out on a channel</li>
</ul>
<div class="highlight"><pre><span></span><code>    for _, s := range []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} {
        select {
        case &lt;-done:
            return
        case stringStream &lt;- s:
        }
    }
</code></pre></div>
<ul>
<li>Looping infinitely waiting to be stopped</li>
</ul>
<div class="highlight"><pre><span></span><code>    for {
        select {
        case &lt;-done:
            return
        default:
        }
        // do non-preemptable work
    }
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="n">for</span> <span class="p">{</span>
    <span class="n">select</span> <span class="p">{</span>
    <span class="n">case</span> <span class="o">&lt;-</span><span class="n">done</span><span class="o">:</span>
        <span class="n">return</span>
    <span class="n">default</span><span class="o">:</span>
    <span class="p">}</span>
    <span class="o">//</span> <span class="n">do</span> <span class="n">non</span><span class="o">-</span><span class="n">preemptable</span> <span class="n">work</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="preventing-goroutine-leaksgoroutine">Preventing Goroutine Leaks(goroutine 泄露)<a class="headerlink" href="#preventing-goroutine-leaksgoroutine" title="Permanent link">&para;</a></h3>
<p><strong>Goroutine are not garbage collected by the runtime.</strong>
The goroutine has a few paths to terminiation:</p>
<ul>
<li>when it has completed its work</li>
<li>when it cannnot continue its work due to an unrecoverable error</li>
<li>when it&rsquo;s told to stop working</li>
</ul>
<p>A simple example of a goroutine leak:</p>
<p><div class="highlight"><pre><span></span><code>func main() {
    doWork := func(strings &lt;-chan string) &lt;-chan interface{} {
        completed := make(chan interface{})
        go func() {
            defer fmt.Println(&quot;doWork exited.&quot;)
            defer close(completed)
            for s := range strings {
                // do something interesting
                fmt.Println(s)
            }
        }()
        return completed
    }
    //pass nil, the strings channel will never actually gets any strings written onto it
    //and the goroutine doWork will remain in memory for the lifetime of this process
    doWork(nil)
    // perhaps more work is done here
    fmt.Println(&quot;Done.&quot;)
}
</code></pre></div>
Use signal done. The parent goroutine passed this channel to child goroutine,
and then closes the channel when it wants to cancel the child goroutine.</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {

    doWork := func(
        done &lt;-chan interface{},
        strings &lt;-chan string,
    ) &lt;-chan interface{} {
        terminated := make(chan interface{})
        go func() {
            defer fmt.Println(&quot;doWork exited&quot;)
            defer close(terminated)
            for {
                select {
                case s := &lt;-strings:
                    //do somthing
                    fmt.Println(s)
                case &lt;-done:
                    return
                }
            }
        }()

        done := make(chan interface{})
        terminated := doWork(done, nil)

        go func() {
            // cancel operation after 1 second
            time.Sleep(1 * time.Second)
            fmt.Println(&quot;canceling doWork goroutine...&quot;)
            close(done)
        }()

        &lt;-terminated // joined the goroutine
        fmt.Println(&quot;Done&quot;)
    }
}
</code></pre></div>
<p>What if a goroutine blocked on attempting wo write a value to a channel?</p>
<div class="highlight"><pre><span></span><code>func main() {
    newRandStream := func() &lt;-chan int {
        randStream := make(chan int)
        go func() {
            defer fmt.Println(&quot;newRandStream closure exited.&quot;) //never run
            defer close(randStream)
            for {
                randStream &lt;- rand.Int()
            }
        }()
        return randStream
    }

    randStream := newRandStream()
    fmt.Println(&quot;3 random ints:&quot;)
    for i := 1; i &lt;= 3; i++ {
        fmt.Printf(&quot;%d:%d\n&quot;, i, &lt;-randStream)
    }
    // 依然退出，输出1到3
}
</code></pre></div>
<p>We can also use a done channel:</p>
<div class="highlight"><pre><span></span><code>func main() {
    newRandStream := func(done &lt;-chan interface{}) &lt;-chan int {
        randStream := make(chan int)
        go func() {
            defer fmt.Println(&quot;newRandStream closure exited.&quot;) //never run
            defer close(randStream)
            for {
                select {
                case randStream &lt;- rand.Int():
                case &lt;-done:
                    return
                }
            }
        }()
        return randStream
    }

    done :=make(chan interface{})
    randStream := newRandStream()
    fmt.Println(&quot;3 random ints:&quot;)
    for i := 1; i &lt;= 3; i++ {
        fmt.Printf(&quot;%d:%d\n&quot;, i, &lt;-randStream)
    }
    close(done)
}
</code></pre></div>
<p>NOTE: If a goroutine is responsible for creating a goroutine, it is also responsible for ensuring
it can stop the gorutine.</p>
<h3 id="the-or-channel-pattern">The or-channel pattern<a class="headerlink" href="#the-or-channel-pattern" title="Permanent link">&para;</a></h3>
<p>At times you may find yourself wanting to combine one or more done channels into a single done channel
that closes if any of its component channels close.
This pattern creates a composite done channel through recursion and goroutines.</p>
<div class="highlight"><pre><span></span><code>func main() {
    var or func(channels ...&lt;-chan interface{}) &lt;-chan interface{}
    or = func(channels ...&lt;-chan interface{}) &lt;-chan interface{} {
        switch len(channels) {
        case 0:
            return nil
        case 1:
            return channels[0]
        }

        orDone := make(chan interface{})
        go func() {
            defer close(orDone)
            switch len(channels) {
            case 2:
                select {
                case &lt;-channels[0]:
                case &lt;-channels[1]:
                }
            default:
                select {
                case &lt;-channels[0]:
                case &lt;-channels[1]:
                case &lt;-channels[2]:
                case &lt;-or(append(channels[3:], orDone)...):
                }
            }
        }()
        return orDone
    }
}

func test() {
    sig := func(after time.Duration) &lt;-chan interface{} {
        c := make(chan interface{})
        go func() {
            defer close(c)
            time.Sleep(after)
        }()
        return c
    }
    start := time.Now()
    &lt;-or(
        sig(2*time.Hour),
        sig(5*time.Minute),
        sig(1*time.Second),
    )
    fmt.Printf(&quot;done after %v\n&quot;, time.Since(start))
}
</code></pre></div>
<h3 id="error-handling">Error Handling<a class="headerlink" href="#error-handling" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

// Result is http result
type Result struct {
    Error    error
    Response *http.Response
}

func main() {
    checkStatus := func(done &lt;-chan interface{}, urls ...string) &lt;-chan Result {
        results := make(chan Result)
        go func() {
            defer close(results)
            for _, url := range urls {
                var result Result
                resp, err := http.Get(url)
                result = Result{Error: err, Response: resp}
                select {
                case &lt;-done:
                    return
                case results &lt;- result:
                }
            }
        }()
        return results
    }

    done := make(chan interface{})
    defer close(done)
    urls := []string{&quot;https://www.baidu.com&quot;, &quot;https://badhost&quot;}
    for result := range checkStatus(done, urls...) {
        if result.Error != nil {
            fmt.Printf(&quot;error:%v&quot;, result.Error)
            continue
        }
        fmt.Printf(&quot;Response: %\n&quot;, result.Response.Status)
    }
}
</code></pre></div>
<p>Errors should be considered first-class citizens when constructing values to return from goroutines.
If your goroutine can produce errors, those errors should be tightly coupled with your result type,
and passed along through the same lines of communication.</p>
<h3 id="pipelines">Pipelines<a class="headerlink" href="#pipelines" title="Permanent link">&para;</a></h3>
<p>It is a very powerful tool to use when your program needs to process streams, or batched of data.</p>
<p>Stage: taskes data in , performs a transformation on it, and sends the data back out</p>
<div class="highlight"><pre><span></span><code>    multiply := func(values []int, multiplier int) []int {
        multipliedValues := make([]int, len(values))
        for i, v := range values {
            multipliedValues[i] = v * multiplier
        }
        return multipliedValues
    }
</code></pre></div>
<h4 id="best-practice-for-constructing-pipelines">Best practice for constructing Pipelines<a class="headerlink" href="#best-practice-for-constructing-pipelines" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>package main

import &quot;fmt&quot;

func main() {
    generator := func(done &lt;-chan interface{}, integers ...int) &lt;-chan int {
        intStream := make(chan int)
        go func() {
            defer close(intStream)
            for _, i := range integers {
                select {
                case &lt;-done:
                    return
                case intStream &lt;- i:
                }
            }
        }()
        return intStream
    }

    multiply := func(done &lt;-chan interface{}, intStream &lt;-chan int, multiplier int) &lt;-chan int {
        multipliedStream := make(chan int)
        go func() {
            defer close(multipliedStream)
            for i := range intStream {
                select {
                case &lt;-done:
                    return
                case multipliedStream &lt;- i * multiplier:
                }
            }
        }()
        return multipliedStream
    }

    add := func(done &lt;-chan interface{}, intStream &lt;-chan int, additive int) &lt;-chan int {
        addedStream := make(chan int)
        go func() {
            defer close(addedStream)
            for i := range intStream {
                select {
                case &lt;-done:
                    return
                case addedStream &lt;- i + additive:
                }
            }
        }()
        return addedStream
    }

    done := make(chan interface{})
    defer close(done)

    intStream := generator(done, 1, 2, 3, 4)
    pipeline := multiply(done, add(done, multiply(done, intStream, 2), 1), 2)
    for v := range pipeline {
        fmt.Println(v)
    }

}
</code></pre></div>
<h4 id="some-handy-generators">Some Handy Generators<a class="headerlink" href="#some-handy-generators" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>package main

import &quot;fmt&quot;

func main() {

    repeat := func(done &lt;-chan interface{}, values ...interface{}) &lt;-chan interface{} {
        valueStream := make(chan interface{})
        go func() {
            defer close(valueStream)
            for {
                for _, v := range values {
                    select {
                    case &lt;-done:
                        return
                    case valueStream &lt;- v:
                    }
                }
            }
        }()
        return valueStream
    }

    take := func(done &lt;-chan interface{}, valueStream &lt;-chan interface{}, num int) &lt;-chan interface{} {
        takeStream := make(chan interface{})
        go func() {
            defer close(takeStream)
            for i := 0; i &lt; num; i++ {
                select {
                case &lt;-done:
                    return
                case takeStream &lt;- &lt;-valueStream:
                }
            }

        }()
        return takeStream
    }

    done := make(chan interface{})
    defer close(done)

    for num := range take(done, repeat(done, 1), 10) {
        fmt.Printf(&quot;%v &quot;, num)
    }
    // 1 1 1 1 1 1 1 1 1 1

}
</code></pre></div>
<h3 id="fan-out-fan-in">Fan-Out, Fan-In (扇出，扇入)<a class="headerlink" href="#fan-out-fan-in" title="Permanent link">&para;</a></h3>
<p>Fan-out is a term to describe the process of starting multiple gortouine to handle input from the pipeline,
and Fan-in is a term to describe the process of combining results into one channel.</p>
<p>Fanout one of your stages if both of the following apply:</p>
<ul>
<li>It doesn&rsquo;t rely on values that the stage had calulated before.</li>
<li>It takes a long time to run</li>
</ul>
<h3 id="the-or-done-channel">The or-done-channel<a class="headerlink" href="#the-or-done-channel" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>    orDone := func(done, c &lt;-chan interface{}) &lt;-chan interface{} {
        valStream := make(chan interface{})
        go func() {
            defer close(valStream)
            for {
                select {
                case &lt;-done:
                    return
                case v, ok := &lt;-c:
                    if ok == false {
                        return
                    }
                    select {
                    case valStream &lt;- v:
                    case &lt;-done:
                    }
                }
            }
        }()
        return valStream
    }

    for val := range orDone(done, myChan) {
        // Do something with val
    }
</code></pre></div>
<h3 id="the-tee-channel">The tee-channel<a class="headerlink" href="#the-tee-channel" title="Permanent link">&para;</a></h3>
<p>Sometimes you may want to split values coming in from a channel so that you can send them off
into two separate areas of your codebase.</p>
<p>You can pass it a channel to read from , and it will return two seperate channels that will get the same value:</p>
<div class="highlight"><pre><span></span><code>package main

import &quot;fmt&quot;

func main() {
    tee := func(done &lt;-chan interface{}, in &lt;-chan interface{}) (&lt;-chan interface{}, &lt;-chan interface{}) {
        out1 := make(chan interface{})
        out2 := make(chan interface{})
        go func() {
            defer close(out1)
            defer close(out2)
            for val := range orDone(done, in) {
                var out1, out2 = out1, out2 //shadow the variables
                for i := 0; i &lt; 2; i++ {
                    select {
                    case &lt;-done:
                    case out1 &lt;- val:
                        // set its shadowed copy to nil,so further writes will block and the other channel may continue
                        out1 = nil
                    case out2 &lt;- val:
                        out2 = nil
                    }
                }
            }
        }()
        return out1, out2
    }

    done := make(chan interface{})
    defer close(done)
    out1, out2 := tee(done, take(done, repeat(done, 1, 2), 4))

    for val1 := range out1 {
        fmt.Printf(&quot;out1: %v, out2:%v\n&quot;, val1, &lt;-out2)
    }
}
</code></pre></div>
<h3 id="the-bridge-channel">The bridge-channel<a class="headerlink" href="#the-bridge-channel" title="Permanent link">&para;</a></h3>
<p>define a function that can destructure the channel of channels into s simple channel(bridging the channels)</p>
<div class="highlight"><pre><span></span><code>package main

import &quot;fmt&quot;

func main() {
    bridge := func(done &lt;-chan interface{}, chanStream &lt;-chan &lt;-chan interface{}) &lt;-chan interface{} {
        valStream := make(chan interface{})
        go func() {
            defer close(valStream)
            for {
                var stream &lt;-chan interface{} //this is the channel that will return all values from bridge
                select {
                case maybeStream, ok := &lt;-chanStream:
                    if ok == false {
                        return
                    }
                    stream = maybeStream
                case &lt;-done:
                    return
                }
                for val := range orDone(done, stream) {
                    select {
                    case valStream &lt;- val:
                    case &lt;-done:
                    }
                }

            }
        }()
        return valStream
    }

    genVals := func() &lt;-chan &lt;-chan interface{} {
        chanStream := make(chan (&lt;-chan interface{}))
        go func() {
            defer close(chanStream)
            for i := 0; i &lt; 10; i++ {
                stream := make(chan interface{}, 1)
                stream &lt;- i
                close(stream)
                chanStream &lt;- stream
            }
        }()
        return chanStream
    }

    for v := range bridge(nil, genVals()) {
        fmt.Printf(&quot;%v &quot;, v) //0 1 2 3 4 5 6 7 8 9
    }
}
</code></pre></div>
<h3 id="queuing">Queuing<a class="headerlink" href="#queuing" title="Permanent link">&para;</a></h3>
<p>queuing should be implemented either:</p>
<ul>
<li>At the entrance to your pipeline</li>
<li>In stages where batching will lead to higher efficiency</li>
</ul>
<h3 id="the-context-package">The context Package<a class="headerlink" href="#the-context-package" title="Permanent link">&para;</a></h3>
<p>context package serves two primary purposes:</p>
<ul>
<li>to provide an API for canceling branches of you call-graph</li>
<li>to provide a data-bag for transporting request-scoped data through your call-graph</li>
</ul>
<h1 id="5-concurrency-at-scale">5. Concurrency at Scale<a class="headerlink" href="#5-concurrency-at-scale" title="Permanent link">&para;</a></h1>
<h3 id="error-progagation">Error Progagation<a class="headerlink" href="#error-progagation" title="Permanent link">&para;</a></h3>
<p>critical information:</p>
<ul>
<li>What happend</li>
<li>When and where it occured(stack track, UTC time, machine)</li>
<li>A friendly usre-facing message</li>
<li>How the user can get more information(track id)</li>
</ul>
<h3 id="timeouts-and-cancellation">Timeouts and Cancellation<a class="headerlink" href="#timeouts-and-cancellation" title="Permanent link">&para;</a></h3>
<p>what the reasons we might want our concurrent processes to support timeouts?</p>
<ul>
<li>System saturation(饱和)</li>
<li>Stale data</li>
<li>Attempting to prevent deadlocks</li>
</ul>
<p>There are a number of reasons why a concurrent process might be canceld:</p>
<ul>
<li>Timeouts, a timeout is an implicit cancellation</li>
<li>User intervention(干预)</li>
<li>Parent cancellation</li>
<li>Replicated requests</li>
</ul>
<h3 id="heartbeats">Heartbeats<a class="headerlink" href="#heartbeats" title="Permanent link">&para;</a></h3>
<p>Heartbeats are a way for concurrent processes to signal life to outside parties. Two diferent types:</p>
<ul>
<li>Heartbeats that occur on a time interval.</li>
<li>Heartbeats that occur at the beginning of a unit of work.</li>
</ul>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    doWork := func(done &lt;-chan interface{}, pulseInterval time.Duration) (chan interface{}, &lt;-chan time.Time) {
        heartbeat := make(chan interface{})
        results := make(chan time.Time)
        go func() {
            defer close(heartbeat)
            defer close(results)

            pulse := time.Tick(pulseInterval)
            workGen := time.Tick(2 * pulseInterval) //another ticker to simulate work coming in

            sendPulse := func() {
                select {
                case heartbeat &lt;- struct{}{}:
                default: // no one maybe listening to our hearteat
                }
            }
            sendResult := func(r time.Time) {
                for {
                    select {
                    case &lt;-done:
                        return
                    case &lt;-pulse:
                        sendPulse()
                    case results &lt;- r:
                        return
                    }
                }
            }

            for {
                select {
                case &lt;-done:
                    return
                case &lt;-pulse:
                    sendPulse()
                case r := &lt;-workGen:
                    sendResult(r)
                }
            }
        }()
        return heartbeat, results
    }

    done := make(chan interface{})
    time.AfterFunc(10*time.Second, func() { close(done) })

    const timeout = 2 * time.Second
    heartbeat, results := doWork(done, timeout/2)
    for {
        select {
        case _, ok := &lt;-heartbeat:
            if ok == false {
                return
            }
            fmt.Println(&quot;pulse&quot;)
        case r, ok := &lt;-results:
            if ok == false {
                return
            }
            fmt.Printf(&quot;results %v\n&quot;, r.Second())
        case &lt;-time.After(timeout):
            return
        }
    }

}
</code></pre></div>
<p>For any long-running goroutines, or goroutines that need to be tested, highly recommend this pattern.</p>
<h3 id="replicated-request">Replicated Request<a class="headerlink" href="#replicated-request" title="Permanent link">&para;</a></h3>
<p>You can replicate the request to mulitple handlers(whether those be gorutines, processes, or servers),
and one of them will run faster than other ones, you can then immediately return the result.
The downside is that you&rsquo;ll have to utilize resources to keep multiple copies of the handlers running.</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    doWork := func(done &lt;-chan interface{}, id int, wg *sync.WaitGroup, result chan&lt;- int) {
        started := time.Now()
        defer wg.Done()

        //Simulate random load
        simulateLoadTime := time.Duration(1+rand.Intn(5)) * time.Second
        select {
        case &lt;-done:
        case &lt;-time.After(simulateLoadTime):
        }
        select {
        case &lt;-done:
        case result &lt;- id:
        }

        took := time.Since(started)
        if took &lt; simulateLoadTime {
            took = simulateLoadTime
        }
        fmt.Printf(&quot;%v took %v\n&quot;, id, took)
    }

    done := make(chan interface{})
    result := make(chan int)
    var wg sync.WaitGroup
    wg.Add(10)

    for i := 0; i &lt; 10; i++ {
        go doWork(done, i, &amp;wg, result) //start 10 handlers to handle our request
    }
    firstReturned := &lt;-result // grabs the first return value from the group of handlers
    close(done)               //cancel all the remaining handlers
    wg.Wait()
    fmt.Printf(&quot;Received an answer from #%v\n&quot;, firstReturned)
}
</code></pre></div>
<h3 id="rate-limiting">Rate Limiting<a class="headerlink" href="#rate-limiting" title="Permanent link">&para;</a></h3>
<p>Most rate limitings is done by utilizing an algorithm called the &ldquo;token bucket&rdquo;.</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;context&quot;
    &quot;log&quot;
    &quot;os&quot;
    &quot;sync&quot;

    &quot;golang.org/x/time/rate&quot; // go get github.com/golang/time/rate
)

func Open() *APIConnection {
    return &amp;APIConnection{
        rateLimiter: rate.NewLimiter(rate.Limit(1), 1), //1 event per second
    }
}

type APIConnection struct {
    rateLimiter *rate.Limiter // https://godoc.org/golang.org/x/time/rate
}

func (a *APIConnection) ReadFile(ctx context.Context) error {
    if err := a.rateLimiter.Wait(ctx); err != nil {
        return err
    }
    return nil
}
func (a *APIConnection) ResoveAddress(ctx context.Context) error {
    if err := a.rateLimiter.Wait(ctx); err != nil {
        return err
    }
    return nil
}

func main() {
    defer log.Printf(&quot;Done&quot;)
    log.SetOutput(os.Stdout)
    log.SetFlags(log.Ltime | log.LUTC)
    apiConnection := Open()
    var wg sync.WaitGroup
    wg.Add(20)

    for i := 0; i &lt; 10; i++ {
        go func() {
            defer wg.Done()
            err := apiConnection.ReadFile(context.Background())
            if err != nil {
                log.Printf(&quot;cannot ReadFile :%v&quot;, err)
            }
            log.Printf(&quot;ReadFile&quot;)
        }()
    }

    for i := 0; i &lt; 10; i++ {
        go func() {
            defer wg.Done()
            err := apiConnection.ResoveAddress(context.Background())
            if err != nil {
                log.Printf(&quot;cannot ResolveAddress :%v&quot;, err)
            }
            log.Printf(&quot;ResolveAddress&quot;)
        }()
    }
    wg.Wait()

}
</code></pre></div>
<p>It&rsquo;s eaiser to keep the limiters separate and then combine them into one rate limiter that manages the interaction for
you.</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;context&quot;
    &quot;sort&quot;
    &quot;time&quot;

    &quot;golang.org/x/time/rate&quot; // go get github.com/golang/time/rate
)

type RateLimiter interface {
    Wait(context.Context) error
    Limit() rate.Limit
}

func MultiLimiter(limiters ...RateLimiter) *multiLimiter {
    byLimit := func(i, j int) bool {
        return limiters[i].Limit() &lt; limiters[j].Limit()
    }
    sort.Slice(limiters, byLimit)
    return &amp;multiLimiter{limiters: limiters}
}

type multiLimiter struct {
    limiters []RateLimiter
}

func (l *multiLimiter) Wait(ctx context.Context) error {
    for _, l := range l.limiters {
        if err := l.Wait(ctx); err != nil {
            return err
        }
    }
    return nil
}

func (l *multiLimiter) Limit() rate.Limit {
    // return the most restrictive limit
    return l.limiters[0].Limit()
}

func Open() *APIConnnection {
    secondLimit := rate.NewLimiter(Per(2, time.Second), 1)
    minuteLimit := rate.NewLimiter(Per(10, time.Minute), 10)
    return &amp;APIConnnection{
        rateLimiter: MultiLimiter(secondLimit, minuteLimit),
    }
}

type APIConnnection struct {
    rateLimiter RateLimiter
}

func (a *APIConnnection) ReadFile(ctx context.Context) error {
    if err := a.rateLimiter.Wait(ctx); err != nil {
        return err
    }
    return nil
}

func (a *APIConnnection) ResolveAddress(ctx context.Context) errro {
    if err := a.rateLimiter.Wait(ctx); err != nil {
        return err
    }
    return nil
}
</code></pre></div>
<h3 id="healing-unhealthy-goroutines">Healing Unhealthy Goroutines<a class="headerlink" href="#healing-unhealthy-goroutines" title="Permanent link">&para;</a></h3>
<p>Ensure your long-lived goroutines stay up and healthy.</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;log&quot;
    &quot;time&quot;
)

type startGoroutineFn func(done &lt;-chan interface{}, pulseInterval time.Duration) (heartbeat &lt;-chan interface{})

func main() {

    newSteward := func(timeout time.Duration, startGoroutine startGoroutineFn) startGoroutineFn {
        return func(done &lt;-chan interface{}, pulseInterval time.Duration) &lt;-chan interface{} {
            heartbeat := make(chan interface{})
            go func() {
                defer close(heartbeat)

                var wardDone chan interface{}
                var wardHeartbeat &lt;-chan interface{}
                startWard := func() {
                    wardDone = make(chan interface{})
                    wardHeartbeat = startGoroutine(or(wardDone, done), timeout/2)
                }
                startWard()
                pulse := time.Tick(pulseInterval)

            monitorLoop:
                for {
                    timeoutSignal := time.After(timeout)
                    for {
                        select {
                        case &lt;-pulse:
                            select {
                            case heartbeat &lt;- struct{}{}:
                            default:
                            }
                        case &lt;-wardHeartbeat:
                            continue monitorLoop
                        case &lt;-timeoutSignal:
                            log.Println(&quot;steward: ward unhealthy: restarting&quot;)
                            close(wardDone)
                            startWard()
                            continue monitorLoop
                        case &lt;-done:
                            return
                        }
                    }

                }
            }()
            return heartbeat
        }
    }
}
</code></pre></div>
<h1 id="6-goroutines-and-the-go-runtime">6 Goroutines and the Go Runtime<a class="headerlink" href="#6-goroutines-and-the-go-runtime" title="Permanent link">&para;</a></h1>
<h3 id="work-stealing">Work Stealing<a class="headerlink" href="#work-stealing" title="Permanent link">&para;</a></h3>
<p>work stealing strategy. Go follows a fork-join model for concurrency.
Forks are when goroutines are started, and join points are when two or more goroutines are
synchronized through channels or types in the sync package.</p>
<p>The work stealing algorithm follows a few basic rules, Given a thread of execution:</p>
<ol>
<li>At A fork point, add tasks to the tail of the deque associated with the thread</li>
<li>If the thread is idle, steal work from the head of deque associated with some other random thread</li>
<li>At a join point that cannot be realized yet(i.e.,the goroutine it is synchronized with has not completed yet), pop
     work off the tail of the thread&rsquo;s own deque.</li>
<li>if the thread&rsquo;s deque is empty, either:
  - stall at a join
  - steal work from the head of a random thread&rsquo;s associated deque</li>
</ol>
<h3 id="stealing-tasks-or-continuations">Stealing Tasks or Continuations?<a class="headerlink" href="#stealing-tasks-or-continuations" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>func main() {
    var fib func(n int) &lt;-chan int
    fib = func(n int) &lt;-chan int {
        result := make(chan int)
        go func() { // tasks
            defer close(result)
            if n &lt;= 2 {
                result &lt;- 1
                return
            }
            result &lt;- &lt;-fib(n-1) + &lt;-fib(n-2)
        }()
        return result // continuation
    }
    fmt.Printf(&quot;fib = %d&quot;, &lt;-fib(4))
}
</code></pre></div>
<ul>
<li>In go , goroutines are tasks</li>
<li>Everything after a goroutine is called is the continuation</li>
</ul>
<p>Continuation stealing is how Go&rsquo;s work-stealing algorithm is implemented</p>
<p>Go&rsquo;s scheduler has three main concepts:</p>
<ul>
<li>G: A Goroutine</li>
<li>M: An OS thread(also referenced as a machine in the source code)</li>
<li>P: A context(also referecned as a processor in the source code), GOMAXPROCS</li>
</ul>
<h1 id="appendix">Appendix<a class="headerlink" href="#appendix" title="Permanent link">&para;</a></h1>
<h3 id="anatomy-of-a-goroutine-error">Anatomy of a Goroutine Error<a class="headerlink" href="#anatomy-of-a-goroutine-error" title="Permanent link">&para;</a></h3>
<p>Prior to Go1.6, when a goroutine panicked, the runtime would print stack traces of all the currently executing
goroutines.</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    //go run -race main.go
    var data int
    go func() {
        data++
    }()
    if data == 0 {
        fmt.Printf(&quot;value is %v\n&quot;, data)
    }
}
</code></pre></div>
<h3 id="race-detection">Race Detection<a class="headerlink" href="#race-detection" title="Permanent link">&para;</a></h3>
<p>go run -race main.go</p>
<h3 id="pprof">pprof<a class="headerlink" href="#pprof" title="Permanent link">&para;</a></h3>
<p><code>runtime/pporf</code> package has predefined profiles to hook into and display:</p>
<ul>
<li>goroutine</li>
<li>heap</li>
<li>threadcreate</li>
<li>block</li>
<li>primitives</li>
<li>mutex</li>
</ul>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;log&quot;
    &quot;os&quot;
    &quot;runtime/pprof&quot;
    &quot;time&quot;
)

func main() {
    log.SetFlags(log.Ltime | log.LUTC)
    log.SetOutput(os.Stdout)

    //every second , log how many goroutines are currently running
    go func() {
        goroutines := pprof.Lookup(&quot;goroutine&quot;)
        for range time.Tick(1 * time.Second) {
            log.Printf(&quot;goroutine count:%d\n&quot;, goroutines.Count())
        }
    }()

    //create some goroutines which will never exit
    var blockForever chan struct{}
    for i := 0; i &lt; 10; i++ {
        go func() { &lt;-blockForever }()
        time.Sleep(500 * time.Millisecond)
    }
}
</code></pre></div>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.2a1c317c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.3a4b43e5.min.js"></script>
      
        <script src="../../../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
    
  </body>
</html>