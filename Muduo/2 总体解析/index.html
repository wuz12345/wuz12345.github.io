
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="wuzhuang">
      
      
        <meta name="author" content="wuzhuang">
      
      
        <link rel="canonical" href="https://wuz12345.github.io/Muduo/2%20%E6%80%BB%E4%BD%93%E8%A7%A3%E6%9E%90/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.2.16">
    
    
      
        <title>muduo 的架构和概念 - wuzhuang</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.1c3799f8.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cc9b2e1e.min.css">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#muduo" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="wuzhuang" class="md-header__button md-logo" aria-label="wuzhuang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            wuzhuang
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              muduo 的架构和概念
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/wuz12345/mynote/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="wuzhuang" class="md-nav__button md-logo" aria-label="wuzhuang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    wuzhuang
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/wuz12345/mynote/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        简介
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../about/" class="md-nav__link">
        关于
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          LearnGo
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LearnGo" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          LearnGo
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnGo/Read/" class="md-nav__link">
        简介
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          LearnC++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LearnC++" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          LearnC++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1" type="checkbox" id="__nav_4_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1">
          模板和泛型编程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="模板和泛型编程" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          模板和泛型编程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/READ/" class="md-nav__link">
        简介
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E7%B1%BB%E6%A8%A1%E6%9D%BF/" class="md-nav__link">
        类模板
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E6%97%A0%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/" class="md-nav__link">
        非类型模板参数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%A8%A1%E7%89%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" class="md-nav__link">
        可变类型模板
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/" class="md-nav__link">
        拷贝赋值
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_3" type="checkbox" id="__nav_4_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_3">
          Effiective Modern C++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Effiective Modern C++" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_3">
          <span class="md-nav__icon md-icon"></span>
          Effiective Modern C++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item01/" class="md-nav__link">
        item1
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item02/" class="md-nav__link">
        item2
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item07/" class="md-nav__link">
        item7
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/" class="md-nav__link">
        左值与右值
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          LeetCode刷题
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LeetCode刷题" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          LeetCode刷题
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LeetCode%20%E5%88%B7%E9%A2%98/Zigzag-Conversion/" class="md-nav__link">
        之字形转换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LeetCode%20%E5%88%B7%E9%A2%98/%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="md-nav__link">
        线性表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          有趣的知识
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="有趣的知识" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          有趣的知识
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" class="md-nav__link">
        正则表达式与有限状态机
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%9F%A5%E8%AF%86/max_and_min/" class="md-nav__link">
        max()函数怎么写
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          webRTC
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="webRTC" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          webRTC
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../webrtc/FEC/FEC/" class="md-nav__link">
        FEC
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
  <a href="https://github.com/wuz12345/mynote/edit/master/docs/Muduo/2 总体解析.md" title="Edit this page" class="md-content__button md-icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>



<h1 id="muduo">muduo 的架构和概念<a class="headerlink" href="#muduo" title="Permanent link">&para;</a></h1>
<p>muduo 中类的职责和概念划分的非常清晰，在《Linux 多线程服务器端编程》一书的 6.3.1 章节有详细的介绍。实际上目前很多网络库的接口设计也都受到了 muduo 的影响，例如 360 的 evpp 等。</p>
<p>而 muduo 的整体风格受到 Netty 的影响，整个架构依照 Reactor 模式，基本与如下图所示相符：</p>
<p><img alt="单线程 Reactor 模式" src="https://www.cyhone.com/img/reactor/single_thread_reactor.png" /></p>
<p>所谓 Reactor 模式，是指有一个循环的过程，不断监听对应事件是否触发，事件触发时调用对应的 callback 进行处理。</p>
<p>这里的事件在 muduo 中包括 Socket 可读写事件、定时器事件。在其他网络库中如 libevent 也包括了 signal、用户自定义事件等。</p>
<p>负责事件循环的部分在 muduo 被命名为 <code>EventLoop</code>，这个命名也基本是个约定语了，其他库如 Netty、libevent 也都有对应的组件。</p>
<p>负责监听事件是否触发的部分，在 muduo 中叫做 <code>Poller</code>。muduo 提供了 epoll 和 poll 两种来实现，默认是 epoll 实现。
通过环境变量 <code>MUDUO_USE_POLL</code> 来决定是否使用 poll:</p>
<div class="highlight"><pre><span></span><code>Poller* Poller::newDefaultPoller(EventLoop* loop)
{
  // 通过此环境变量来决定使用 poll 还是 epoll
  if (::getenv(&quot;MUDUO_USE_POLL&quot;))
  {
    return new PollPoller(loop);
  }
  else
  {
    return new EPollPoller(loop);
  }
}
</code></pre></div>
<p>此外，上图中的 acceptor 负责 accept 新连接，并将新连接分发到 subReactor。这个组件在 muduo 中也叫做 <code>Acceptor</code>。
关于图中的其他部分，会在 <a href="#muduo 的线程模型">muduo 的线程模型</a> 一节有详细介绍。</p>
<h1 id="_1">一个简单的例子<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<p>本文首先从最简单的 echo server 入手，来介绍 muduo 的基本使用，同时也方便后面概念的理解。</p>
<div class="highlight"><pre><span></span><code>void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,
                           muduo::net::Buffer* buf,
                           muduo::Timestamp time)
{
  conn-&gt;send(buf);
}

int main()
{
    muduo::net::EventLoop loop;
    muduo::net::InetAddress listenAddr(2007);
    TcpServer server(&amp;loop, listenAddr);
    server.setMessageCallback(onMessage);
    server.start();
    loop.loop();
}
</code></pre></div>
<p>echo-server 的代码量非常简洁。一个典型的 muduo 的 TcpServer 工作流程如下：</p>
<ol>
<li>建立一个事件循环器 EventLoop</li>
<li>建立对应的业务服务器 TcpServer</li>
<li>设置 TcpServer 的 Callback</li>
<li>启动 server</li>
<li>开启事件循环</li>
</ol>
<p>陈硕认为，TCP 网络编程的本质是处理三个半事件，即：</p>
<ol>
<li>连接的建立</li>
<li>连接的断开：包括主动断开和被动断开</li>
<li>消息到达，文件描述符可读。</li>
<li>消息发送完毕。这个算半个事件。</li>
</ol>
<p>我们接下来分析下 muduo 是怎么处理和实现这三个半事件的</p>
<h1 id="_2">连接的建立<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h1>
<p>在我们单纯使用 linux 的 API，编写一个简单的 Tcp 服务器时，建立一个新的连接通常需要四步：</p>
<blockquote>
<p>步骤 1. socket() // 调用 socket 函数建立监听 socket
步骤 2. bind() // 绑定地址和端口
步骤 3. listen() // 开始监听端口
步骤 4. accept() // 返回新建立连接的 fd</p>
</blockquote>
<p>我们接下来分析下，这四个步骤在 muduo 中都是何时进行的：</p>
<p>首先在 TcpServer 对象构建时，TcpServer 的属性 acceptor 同时也被建立。
在 Acceptor 的构造函数中分别调用了 socket 函数和 bind 函数完成了 <strong>步骤 1**和**步骤 2</strong>。
即，当 <code>TcpServer server(&amp;loop, listenAddr)</code> 执行结束时，监听 socket 已经建立好，并已绑定到对应地址和端口了。</p>
<p>而当执行 <code>server.start()</code> 时，主要做了两个工作：</p>
<ol>
<li>在监听 socket 上启动 listen 函数，也就是 <strong>步骤 3</strong>；</li>
<li>将监听 socket 的可读事件注册到 EventLoop 中。</li>
</ol>
<p>此时，程序已完成对socket的监听，但还不够，因为此时程序的主角 <code>EventLoop</code> 尚未启动。
当调用 <code>loop.loop()</code> 时，程序开始循环监听该 socket 的可读事件。</p>
<p>当新连接请求建立时，可读事件触发，此时该事件对应的 callback 在 EventLoop::loop() 中被调用。
该事件的 callback 实际上就是 Acceptor::handleRead() 方法。</p>
<p>在 Acceptor::handleRead() 方法中，做了三件事：</p>
<ol>
<li>调用了 accept 函数，完成了 <strong>步骤 4</strong>，实现了连接的建立。得到一个已连接 socket 的 fd。</li>
<li>创建 TcpConnection 对象。</li>
<li>将已连接 socket 的可读事件注册到 EventLoop 中。</li>
</ol>
<p>这里还有一个需要注意的点，创建的 TcpConnnection 对象是个 shared_ptr，该对象会被保存在 TcpServer 的 connections 中。这样才能保证引用计数大于 0，对象不被释放。</p>
<p>至此，一个新的连接已完全建立好，该连接的socket可读事件也已注册到 EventLoop 中了。</p>
<h1 id="_3">消息的读取<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h1>
<p>上节讲到，在新连接建立的时候，会将新连接的 socket 的可读事件注册到 EventLoop 中。
假如客户端发送消息，导致已连接 socket 的可读事件触发，该事件对应的 callback 同样也会在 EventLoop::loop() 中被调用。</p>
<p>该事件的 callback 实际上就是 TcpConnection::handleRead 方法。
在 TcpConnection::handleRead 方法中，主要做了两件事：</p>
<ol>
<li>从 socket 中读取数据，并将其放入 inputbuffer 中</li>
<li>调用 messageCallback，执行业务逻辑。</li>
</ol>
<div class="highlight"><pre><span></span><code>ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);
if (n&gt; 0)
{
    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);
}
</code></pre></div>
<p>messageCallback 是在建立新连接时，将 <code>TcpServer::messageCallback</code> 方法 bind 到了 <code>TcpConnection::messageCallback</code> 的方法。</p>
<p><code>TcpServer::messageCallback</code> 就是业务逻辑的主要实现函数。通常情况下，我们可以在里面实现消息的编解码、消息的分发等工作，这里就不再深入探讨了。</p>
<p>在我们上面给出的示例代码中，echo-server 的 messageCallback 非常简单，就是直接将得到的数据，重新 send 回去。在实际的业务处理中，一般都会调用 TcpConnection::send() 方法，给客户端回复消息。</p>
<p>这里需要注意的是，在 messageCallback 中，用户会有可能会把任务抛给自定义的 Worker 线程池处理。
但是这个在 Worker 线程池中任务，<strong>切忌直接对 Buffer 的操作</strong>。因为 Buffer 并不是线程安全的。</p>
<p>我们需要记住一个准则:</p>
<blockquote>
<p><strong>所有对 IO 和 buffer 的读写，都应该在 IO 线程中完成。</strong></p>
</blockquote>
<p>一般情况下，先在交给 Worker 线程池之前，应该现在 IO 线程中把 Buffer 进行切分解包等动作。将解包后的消息交由线程池处理，避免多个线程操作同一个资源。</p>
<h1 id="_4">消息的发送<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h1>
<p>用户通过调用 TcpConnection::send() 向客户端回复消息。由于 muduo 中使用了 OutputBuffer，因此消息的发送过程比较复杂。</p>
<p>首先需要注意的是线程安全问题, 上文说到对于消息的读写必须都在 EventLoop 的同一个线程 (通常称为 IO 线程) 中进行：
因此，TcpConnection::send 必须要保证线程安全性，它是这么做的：</p>
<div class="highlight"><pre><span></span><code>void TcpConnection::send(const StringPiece&amp; message)
{
  if (state_ == kConnected)
  {
    if (loop_-&gt;isInLoopThread())
    {
      sendInLoop(message);
    }
    else
    {
      loop_-&gt;runInLoop(
          boost::bind(&amp;TcpConnection::sendInLoop,
                      this,     // FIXME
                      message.as_string()));
    }
  }
}
</code></pre></div>
<p>检测 send 的时候，是否在当前 IO 线程，如果是的话，直接进行写相关操作 <code>sendInLoop</code>。
如果不在一个线程的话，需要将该任务抛给 IO 线程执行 <code>runInloop</code>, 以保证 write 动作是在 IO 线程中执行的。我们后面会讲解 <code>runInloop</code> 的具体实现。</p>
<p>在 sendInloop 中，做了下面几件事：</p>
<ol>
<li>假如 OutputBuffer 为空，则直接向 socket 写数据</li>
<li>如果向 socket 写数据没有写完，则统计剩余的字节个数，并进行下一步。没有写完可能是因为此时 socket 的 TCP 缓冲区已满了。</li>
<li>如果此时 OutputBuffer 中的旧数据的个数和未写完字节个数之和大于 highWaterMark，则将 highWaterMarkCallback 放入待执行队列中</li>
<li><strong>将对应 socket 的可写事件注册到 EventLoop 中</strong></li>
</ol>
<p>注意：直到发送消息的时候，muduo 才会把 socket 的可写事件注册到了 EventLoop 中。在此之前只注册了可读事件。</p>
<p>连接 socket 的可写事件对应的 callback 是 TcpConnection::handleWrite()
当某个 socket 的可写事件触发时，TcpConnection::handleWrite 会做两个工作：</p>
<ol>
<li>尽可能将数据从 OutputBuffer 中向 socket 中 write 数据</li>
<li>如果 OutputBuffer 没有剩余的，则 <strong>将该 socket 的可写事件移除</strong>，并调用 writeCompleteCallback</li>
</ol>
<h2 id="_5">为什么要移除可写事件<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<p>因为当 OutputBuffer 中没数据时，我们不需要向 socket 中写入数据。但是此时 socket 一直是处于可写状态的， 这将会导致 TcpConnection::handleWrite() 一直被触发。然而这个触发毫无意义，因为并没有什么可以写的。</p>
<p>所以 muduo 的处理方式是，当 OutputBuffer 还有数据时，socket 可写事件是注册状态。当 OutputBuffer 为空时，则将 socket 的可写事件移除。</p>
<p>此外，highWaterMarkCallback 和 writeCompleteCallback 一般配合使用，起到限流的作用。在《linux 多线程服务器端编程》一书的 8.9.3 一节中有详细讲解。这里就不再赘述了</p>
<h1 id="_6">连接的断开<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h1>
<p>我们看下 muduo 对于连接的断开是怎么处理的。
连接的断开分为被动断开和主动断开。主动断开和被动断开的处理方式基本一致，因此本文只讲下被动断开的部分。</p>
<p>被动断开即客户端断开了连接，server 端需要感知到这个断开的过程，然后进行的相关的处理。</p>
<p>其中感知远程断开这一步是在 Tcp 连接的可读事件处理函数 <code>handleRead</code> 中进行的：当对 socket 进行 read 操作时，返回值为 0，则说明此时连接已断开。</p>
<p>接下来会做四件事情：</p>
<ol>
<li>将该 TCP 连接对应的事件从 EventLoop 移除</li>
<li>调用用户的 ConnectionCallback</li>
<li>将对应的 TcpConnection 对象从 Server 移除。</li>
<li>close 对应的 fd。此步骤是在析构函数中自动触发的，当 TcpConnection 对象被移除后，引用计数为 0，对象析构时会调用 close。</li>
</ol>
<h1 id="runinloop">runInLoop 的实现<a class="headerlink" href="#runinloop" title="Permanent link">&para;</a></h1>
<p>在讲解消息的发送过程时候，我们讲到为了保证对 buffer 和 socket 的写动作是在 IO 线程中进行，使用了一个 <code>runInLoop</code> 函数，将该写任务抛给了 IO 线程处理。</p>
<p>我们接下来看下 <code>runInLoop</code> 的实现：</p>
<div class="highlight"><pre><span></span><code>void EventLoop::runInLoop(const Functor&amp; cb)
{
  if (isInLoopThread())
  {
    cb();
  }
  else
  {
    queueInLoop(cb);
  }
}
</code></pre></div>
<p>这里可以看到，做了一层判断。如果调用时是此 EventLoop 的运行线程，则直接执行此函数。
否则调用 <code>queueInLoop</code> 函数。我们看下 <code>queueInLoop</code> 的实现。</p>
<div class="highlight"><pre><span></span><code>void EventLoop::queueInLoop(const Functor&amp; cb)
{
  {
  MutexLockGuard lock(mutex_);
  pendingFunctors_.push_back(cb);
  }

  if (!isInLoopThread() || callingPendingFunctors_)
  {
    wakeup();
  }
}
</code></pre></div>
<p>这里有两个动作：</p>
<ol>
<li>加锁，然后将该函数放到该 EventLoop 的 pendingFunctors_队列中。</li>
<li>判断是否要唤醒 EventLoop，如果是则调用 wakeup() 唤醒该 EventLoop。</li>
</ol>
<p>这里有几个问题：</p>
<ul>
<li>为什么要唤醒 EventLoop？</li>
<li>wakeup 是怎么实现的?</li>
<li>pendingFunctors_是如何被消费的?</li>
</ul>
<h2 id="eventloop">为什么要唤醒 EventLoop<a class="headerlink" href="#eventloop" title="Permanent link">&para;</a></h2>
<p>我们首先调用了 <code>pendingFunctors_.push_back(cb)</code>, 将该函数放在 pendingFunctors_中。EventLoop 的每一轮循环在最后会调用 doPendingFunctors 依次执行这些函数。</p>
<p>而 EventLoop 的唤醒是通过 epoll_wait 实现的，如果此时该 EventLoop 中迟迟没有事件触发，那么 epoll_wait 一直就会阻塞。 这样会导致，pendingFunctors_中的任务迟迟不能被执行了。</p>
<p>所以对必须要唤醒 EventLoop ，让pendingFunctors_中的任务尽快被执行。</p>
<h2 id="wakeup">wakeup 是怎么实现的<a class="headerlink" href="#wakeup" title="Permanent link">&para;</a></h2>
<p>muduo 这里采用了对 eventfd 的读写来实现对 EventLoop 的唤醒。</p>
<p>在 EventLoop 建立之后，就创建一个 eventfd，并将其可读事件注册到 EventLoop 中。</p>
<p><code>wakeup()</code> 的过程本质上是对这个 eventfd 进行写操作，以触发该 eventfd 的可读事件。这样就起到了唤醒 EventLoop 的作用。</p>
<div class="highlight"><pre><span></span><code>void EventLoop::wakeup()
{
  uint64_t one = 1;
  sockets::write(wakeupFd_, &amp;one, sizeof one);
}
</code></pre></div>
<p>很多库为了兼容 macOS，往往使用 pipe 来实现这个功能。muduo 采用了 eventfd，性能更好些，但代价是不能支持 macOS 了。不过 muduo 似乎从一开始的定位就不打算支持？</p>
<h2 id="dopendingfunctors">doPendingFunctors 的实现<a class="headerlink" href="#dopendingfunctors" title="Permanent link">&para;</a></h2>
<p>本部分讲下 <code>doPendingFunctors</code> 的实现，muduo 是如何处理这些待处理的函数的，以及中间用了哪些优化操作。
代码如下所示：</p>
<div class="highlight"><pre><span></span><code>void EventLoop::doPendingFunctors()
{
  std::vector&lt;Functor&gt; functors;

  callingPendingFunctors_ = true;

  {
  MutexLockGuard lock(mutex_);
  functors.swap(pendingFunctors_);
  }

  for (size_t i = 0; i &lt; functors.size(); ++i)
  {
    functors[i]();
  }
  callingPendingFunctors_ = false;
}
</code></pre></div>
<p>从代码可以看到，函数非常简单。大概只有十行代码，但是这十行代码中却有两个非常巧妙的地方。</p>
<ol>
<li><strong>callingPendingFunctors_的作用</strong></li>
</ol>
<p>从代码可以看出，如果 callingPendingFunctors_为 false，则说明此时尚未开始执行 doPendingFunctors 函数。
这个有什么作用呢，我们需要结合下 queueInLoop 中，对是否执行 wakeup() 的判断</p>
<div class="highlight"><pre><span></span><code>if (!isInLoopThread() || callingPendingFunctors_)
{
  wakeup();
}
</code></pre></div>
<p>这里还需要结合下 EventLoop 循环的实现，其中 <code>doPendingFunctors()</code> 是 <strong>每轮循环的最后一步处理</strong>。
如果调用 queueInLoop 和 EventLoop 在同一个线程，且 callingPendingFunctors_为 false 时，则说明：<strong>此时尚未执行到 doPendingFunctors()。</strong>
那么此时即使不用 wakeup，也可以在之后照旧执行 doPendingFunctors() 了。</p>
<p>这么做的好处非常明显，可以减少对 eventfd 的 IO 读写。</p>
<ol>
<li><strong>锁范围的减少</strong>
   在此函数中，有一段特别的代码：</li>
</ol>
<div class="highlight"><pre><span></span><code>std::vector&lt;Functor&gt; functors;
{
  MutexLockGuard lock(mutex_);
  functors.swap(pendingFunctors_);
}
</code></pre></div>
<p>这个作用是 pendingFunctors_和 functors 的内容进行交换，实际上就是此时 functors 持有了 pendingFunctors_的内容，而 pendingFunctors_被清空了。</p>
<p>这个好处是什么呢？
如果不这么做，直接遍历 pendingFunctors_, 然后处理对应的函数。这样的话，锁会一直等到所有函数处理完才会被释放。在此期间，queueInLoop 将不可用。</p>
<p>而以上的写法，可以极大减小锁范围，整个锁的持有时间就是 swap 那一下的时间。待处理函数执行的时候，其他线程还是可以继续调用 queueInLoop。</p>
<h1 id="muduo_1">muduo 的线程模型<a class="headerlink" href="#muduo_1" title="Permanent link">&para;</a></h1>
<p>muduo 默认是单线程模型的，即只有一个线程，里面对应一个 EventLoop。这样整体对于线程安全的考虑可能就比较简单了，
但是 muduo 也可以支持以下几种线程模型：</p>
<h2 id="reactor">主从 reactor 模式<a class="headerlink" href="#reactor" title="Permanent link">&para;</a></h2>
<p>主从 reactor 是 Netty 的默认模型，一个 reactor 对应一个 EventLoop。主 Reactor 只有一个，只负责监听新的连接，accept 后将这个连接分配到子 Reactor 上。子 Reactor 可以有多个。这样可以分摊一个 Eventloop 的压力，性能方面可能会更好。如下图所示：</p>
<p><img alt="主从 Reactor 模式" src="https://www.cyhone.com/img/reactor/main_sub_reactor.jpg" /></p>
<p>在 muduo 中也可以支持主从 Reactor，其中主 Reactor 的 EventLoop 就是 TcpServer 的构造函数中的 <code>EventLoop*</code> 参数。Acceptor 会在此 EventLoop 中运行。</p>
<p>而子 Reactor 可以通过 <code>TcpServer::setThreadNum(int)</code> 来设置其个数。因为一个 Eventloop 只能在一个线程中运行，所以线程的个数就是子 Reactor 的个数。</p>
<p>如果设置了子 Reactor，新的连接会通过 Round Robin 的方式分配给其中一个 EventLoop 来管理。如果没有设置子 Reactor，则是默认的单线程模型，新的连接会再由主 Reactor 进行管理。</p>
<p>但其实这里似乎有些不合适的地方：多个 TcpServer 之间可以共享同一个主 EventLoop，但是子 Eventloop 线程池却不能共享，这个是每个 TcpServer 独有的。
这里不太清楚是 muduo 的设计问题，还是作者有意为之。不过 Netty 的主 EventLoop 和子 Eventloop 池都是可以共享的。</p>
<h2 id="_7">业务线程池<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h2>
<p>对于一些阻塞型或者耗时型的任务，例如 MySQL 操作等。这些显然是不能放在 IO 线程（即 EventLoop 所在的线程）中运行的，因为会严重影响 EventLoop 的正常运行。</p>
<p>对于这类耗时型的任务，一般做法是可以放在另外单独线程池中运行，这样就不会阻塞 IO 线程的运行了。我们一般把这种处理耗时任务的线程叫做 Worker 线程。</p>
<p>muduo 的网络框架本身没有直接集成 Worker 线程池，但是 muduo 的基础库提供了线程池的相关类 <code>ThreadPool</code>。muduo 官方的推荐做法是，在 OnMessage 中，自行进行包的切分，然后将数据和对应的处理函数打包成 Task 的方式提交给线程池。</p>
<p>《Unix 网络编程》一书中提到的几种 IO 模型，我们在开发过程中，讨论最多的应该就是三种： <code>阻塞 IO</code>、<code>非阻塞 IO</code> 以及 <code>异步 IO</code>。</p>
<p>本文试图理清楚几种 IO 模型的根本性区别，同时分析了为什么在 Linux 网络编程中最好要用非阻塞式 IO。</p>
<h1 id="io">网络 IO 概念准备<a class="headerlink" href="#io" title="Permanent link">&para;</a></h1>
<p>在讨论网络 IO 之前，一定要有一个概念上的准备前提: ** 不要用操作磁盘文件的经验去看待网络 IO。** 具体的原因我们在下文中会介绍到。</p>
<p>相比于传统的网络 IO 来说，一个普通的文件描述符的操作可以分为两部分。以 <code>read</code> 为例，我们利用 read 函数从 socket 中同步阻塞的读取数据，整个流程如下所示：</p>
<p><img alt="read 示意图" src="https://www.cyhone.com/img/noblocking-io/block-read.png" /></p>
<ol>
<li>调用 read 后，该调用会转入内核调用</li>
<li>内核会等待该 socket 的可读事件，直到远程向 socket 发送了数据。可读事件成立 (这里还需要满足 TCP 的低水位条件，但是不做太详细的讨论)</li>
<li>数据包到达内核，接着内核将数据拷贝到用户进程中，也就是 read 函数指定的 buffer 参数中。至此，read 调用结束。</li>
</ol>
<p>可以看到除了转入内核调用，与传统的磁盘 IO 不同的是，网络 IO 的读写大致可以分为两个阶段：</p>
<ol>
<li>等待阶段：等待 socket 的可读或者可写事件成立</li>
<li>拷贝数据阶段：将数据从内核拷贝到用户进程，或者从用户进程拷贝到内核中，</li>
</ol>
<h1 id="io_1">三种 IO 模型的区别<a class="headerlink" href="#io_1" title="Permanent link">&para;</a></h1>
<p>我们日常开发遇到最多的三种 IO 模型分别是：同步阻塞 IO、同步非阻塞 IO、异步 IO。</p>
<p>这些名词非常容易混淆，为什么一个 IO 会有两个限定词：同步和阻塞？同步和阻塞分别代表什么意思？
简单来说：</p>
<ol>
<li>等待 <strong>阻塞</strong>: 在 socket 操作的第一个阶段，也就是用户等待 socket 可读可写事件成立的这个阶段。如果一直等待下去，直到成立后，才进行下个阶段，则称为阻塞式 IO；如果发现 socket 非可读可写状态，则直接返回，不等待，也不进行下个阶段，则称为非阻塞式 IO。</li>
<li>拷贝 <strong>同步</strong>: 从内核拷贝到用户空间的这个阶段，如果直到从开始拷贝直到拷贝结束，read 函数才返回，则称为同步 IO。如果在调用 read 的时候就直接返回了，等到数据拷贝结束，才通过某种方式 (例如回调) 通知到用户，这种被称为异步 IO。</li>
</ol>
<p>所谓异步，实际上就是非同步非阻塞。</p>
<h2 id="io_2">同步阻塞 IO<a class="headerlink" href="#io_2" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>read(fd, buffer, count)
</code></pre></div>
<p>Linux 下面如果直接不对 fd 进行特殊处理，直接调用 read，就是同步阻塞 IO。同步阻塞 IO 的两个阶段都需要等待完成后，read 才会返回。</p>
<p><strong>也就是说，如果远程一直没有发送数据，则 read 一直就不会返回，整个线程就会阻塞到这里了。</strong></p>
<h1 id="io_3">同步非阻塞 IO<a class="headerlink" href="#io_3" title="Permanent link">&para;</a></h1>
<p>对于同步非阻塞 IO 来说，如果没有可读可写事件，则直接返回；如果有，则进行第二个阶段，复制数据。
在 linux 下面，需要使用 fcntl 将 fd 变为非阻塞的。</p>
<div class="highlight"><pre><span></span><code>int flags = fcntl(socket, F_GETFL, 0);
fcntl(socket, F_SETFL, flags | O_NONBLOCK);
</code></pre></div>
<p>同时，如果 read 的时候，fd 不可读，则 read 调用会触发一个 EWOULDBLOCK 错误 (或者 EAGAIN，EWOULDBLOCK 和 EAGAIN 是一样的)。用户只要检查下 <code>errno == EWOULDBLOCK</code>, 即可判断 read 是否返回正常。</p>
<p>基本在 Linux 下进行网络编程，非阻塞 IO 都是不二之选。</p>
<h2 id="io_4">异步 IO<a class="headerlink" href="#io_4" title="Permanent link">&para;</a></h2>
<p>Linux 开发者应该很少使用纯粹的异步 IO。因为目前来说，Linux 并没有一个完美的异步 IO 的解决方案。pthread 虽然提供了 aio 的接口，但是这里不做太具体的讨论了。</p>
<p>我们平常接触到的异步 IO 库或者框架都是在代码层面把操作封装成了异步。但是在具体调用 read 或者 write 的时候，一般还是用的非阻塞式 IO。</p>
<h1 id="io-io">不能用操作磁盘 IO 的经验看待网络 IO<a class="headerlink" href="#io-io" title="Permanent link">&para;</a></h1>
<p>为什么不能用操作磁盘 IO 的经验看待网络 IO。实际上在磁盘 IO 中，等待阶段是不存在的，因为磁盘文件并不像网络 IO 那样，需要等待远程传输数据。</p>
<p>所以有的时候，习惯了操作磁盘 IO 的开发者会无法理解同步阻塞 IO 的工作过程，无法理解为什么 read 函数不会返回。</p>
<p>关于磁盘 IO 与同步非阻塞的讨论，在知乎上有一篇帖子 <a href="https://www.zhihu.com/question/52989189">为什么书上说同步非阻塞 io 在对磁盘 io 上不起作用?</a> 讨论了这个问题。</p>
<h1 id="linux-io">为什么在 Linux 网络编程中最好要用非阻塞式 IO？<a class="headerlink" href="#linux-io" title="Permanent link">&para;</a></h1>
<p>上文说到，在 linux 网络编程中，如果使用阻塞式的 IO，假如某个 fd 长期不可读，那么一个线程相应将会被长期阻塞，那么线程资源就会被白白浪费。</p>
<p>那么，如果我们用了 epoll，还必须要使用非阻塞 IO 吗？ 因为如果使用 epoll 监听了 fd 的可读事件，在 epoll_wait 之后调用 read，此时 fd 一定是可读的， 那么此时非阻塞 IO 相比于阻塞 IO 的优势不就没了吗？</p>
<p>实际上，并不是这样的。<strong>epoll 也必须要搭配非阻塞 IO 使用。</strong>
这个帖子 <a href="https://www.zhihu.com/question/37271342">为什么 IO 多路复用要搭配非阻塞 IO?</a> 详细讨论了这个问题？</p>
<p>总结来说，原因有二：</p>
<ol>
<li>fd 在 read 之前有可能会重新进入不可读的状态。要么被其他方式读走了 (参考惊群问题), 还有可能被内核抛弃了，总的来说，fd 因为在 read 之前，数据被其他方式读走，fd 重新变为不可读。此时，用阻塞式 IO 的 read 函数就会阻塞整个线程。</li>
<li>epoll 只是返回了可读事件，但是并没有返回可以读多少数据量。因此，非阻塞 IO 的做法是读多次，直到不能读。而阻塞 io 却只能读一次，因为万一一次就读完了缓冲区所有数据，第二次读的时候，read 就会又阻塞了。但是对于 epoll 的 ET 模式来说，缓冲区的数据只会在改变的通知一次，如果此次没有消费完，在下次数据到来之前，可读事件再也不会通知了。那么对于只能调用一次 read 的阻塞式 IO 来说，未读完的数据就有可能永远读不到了。</li>
</ol>
<p>因此，在 Linux 网络编程中最好使用非阻塞式 IO。</p>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2a1c317c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.3a4b43e5.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
    
  </body>
</html>