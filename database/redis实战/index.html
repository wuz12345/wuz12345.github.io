
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="wuzhuang">
      
      
        <meta name="author" content="wuzhuang">
      
      
        <link rel="canonical" href="https://wuz12345.github.io/database/redis%E5%AE%9E%E6%88%98/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.2.16">
    
    
      
        <title>《Redis 实战》英文名《Redis In Action》笔记 - wuzhuang</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.1c3799f8.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cc9b2e1e.min.css">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#redis-redis-in-action" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="wuzhuang" class="md-header__button md-logo" aria-label="wuzhuang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            wuzhuang
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              《Redis 实战》英文名《Redis In Action》笔记
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/wuz12345/mynote/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="wuzhuang" class="md-nav__button md-logo" aria-label="wuzhuang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    wuzhuang
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/wuz12345/mynote/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        简介
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../about/" class="md-nav__link">
        关于
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          LearnC++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LearnC++" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          LearnC++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/" class="md-nav__link">
        拷贝赋值
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_2" type="checkbox" id="__nav_3_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3_2">
          Effiective Modern C++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Effiective Modern C++" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_2">
          <span class="md-nav__icon md-icon"></span>
          Effiective Modern C++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item01/" class="md-nav__link">
        item1
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item02/" class="md-nav__link">
        item2
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/Effective%20C%2B%2B/Item07/" class="md-nav__link">
        item7
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LearnC%2B%2B/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/" class="md-nav__link">
        左值与右值
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          LeetCode刷题
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="LeetCode刷题" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          LeetCode刷题
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LeetCode%20%E5%88%B7%E9%A2%98/Zigzag-Conversion/" class="md-nav__link">
        之字形转换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LeetCode%20%E5%88%B7%E9%A2%98/%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="md-nav__link">
        线性表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          有趣的知识
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="有趣的知识" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          有趣的知识
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" class="md-nav__link">
        正则表达式与有限状态机
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          webRTC
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="webRTC" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          webRTC
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../webrtc/FEC/FEC/" class="md-nav__link">
        FEC
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
  <a href="https://github.com/wuz12345/mynote/edit/master/docs/database/redis实战.md" title="Edit this page" class="md-content__button md-icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>



<h1 id="redis-redis-in-action">《Redis 实战》英文名《Redis In Action》笔记<a class="headerlink" href="#redis-redis-in-action" title="Permanent link">&para;</a></h1>
<h1 id="1-redis">1. 初识Redis<a class="headerlink" href="#1-redis" title="Permanent link">&para;</a></h1>
<p>5种基本类型：string, list, set, hash, zset
内存存储、远程、持久、可扩展（主从复制和分片）</p>
<h1 id="2-redis-web">2. 使用 Redis 构建 web 应用<a class="headerlink" href="#2-redis-web" title="Permanent link">&para;</a></h1>
<p>典型使用场景：</p>
<ul>
<li>登录和 cookie 缓存。签名(signed)cookie和令牌(token)cookie</li>
<li>用 redis 实现购物车，存储商品 id 和商品订购数量之间的映射</li>
<li>网页缓存，缓存不经常变动的网页结果</li>
<li>缓存部分关系数据库中的行</li>
<li>缓存部分页面：通过页面压缩、Edge Side includes 技术、移除模板无用字符等优化</li>
</ul>
<h1 id="3-redis">3. Redis 命令<a class="headerlink" href="#3-redis" title="Permanent link">&para;</a></h1>
<h3 id="31">3.1 字符串<a class="headerlink" href="#31" title="Permanent link">&para;</a></h3>
<p>redis 里字符串可以存储三种类型的值，字节串(byte string),整数,浮点数</p>
<ul>
<li>incr</li>
<li>decr</li>
<li>incrby</li>
<li>decrby</li>
<li>incrbyfloat</li>
<li>append：追加到值的末尾</li>
<li>getrange: 获取子串</li>
<li>setrange</li>
<li>getbit: 将字节串看作是二进制位串(bit string)，并返回串中偏移量为offset的二进制位的值</li>
<li>setbit</li>
<li>bitcount: 统计二进制串位里值为1的二进制位的数量</li>
<li>bitop: 对一个或者多个二进制位串执行位运算操作</li>
</ul>
<h3 id="32">3.2 列表<a class="headerlink" href="#32" title="Permanent link">&para;</a></h3>
<p>允许从两端推入或者弹出元素</p>
<ul>
<li>rpush</li>
<li>lpush</li>
<li>rpop</li>
<li>lpop</li>
<li>lindex</li>
<li>lrange</li>
<li>ltrim</li>
</ul>
<p>阻塞式的列表弹出命令以及在列表之间移动元素的命令。常用在消息传递(messaging)和任务队列(task queue)</p>
<ul>
<li>blpop</li>
<li>brpop</li>
<li>rpoplpush</li>
<li>brpoplpush</li>
</ul>
<h3 id="33">3.3 集合<a class="headerlink" href="#33" title="Permanent link">&para;</a></h3>
<p>无序存储多个不同的元素</p>
<ul>
<li>sadd</li>
<li>srem</li>
<li>sismember</li>
<li>scard</li>
<li>smembers</li>
<li>srandmember</li>
<li>spop</li>
<li>smove</li>
</ul>
<p>组合和关联多个集合</p>
<ul>
<li>sdiff</li>
<li>sdiffstore: 差集</li>
<li>sinter</li>
<li>sinterstore</li>
<li>sunion</li>
<li>sunionstore</li>
</ul>
<h3 id="34">3.4 散列<a class="headerlink" href="#34" title="Permanent link">&para;</a></h3>
<p>多个键值对存储到一个 redis 键里</p>
<ul>
<li>hmget</li>
<li>hmset</li>
<li>hdel</li>
<li>hlen</li>
<li>hexists</li>
<li>hkeys</li>
<li>hvals</li>
<li>hgetall</li>
<li>hincrby</li>
<li>hincrybyfloat</li>
</ul>
<h3 id="35">3.5 有序集合<a class="headerlink" href="#35" title="Permanent link">&para;</a></h3>
<p>根据分值大小有序获取(fetch)或扫描(scan)成员和分值</p>
<ul>
<li>zadd</li>
<li>zrem</li>
<li>zcard</li>
<li>zincrby</li>
<li>zcount</li>
<li>zrank</li>
<li>zscore</li>
<li>zrange</li>
</ul>
<p>范围命令，并集和交集命令。rev 逆序表示分值从大到小排列</p>
<ul>
<li>zrevrank: 分值从大到小排列</li>
<li>zrevrange</li>
<li>zrangebyscore</li>
<li>zrevrangebyscore</li>
<li>zremrangebyrank</li>
<li>zremrangebyscore</li>
<li>zinterstore</li>
<li>zunionstore</li>
</ul>
<h3 id="36">3.6 发布订阅<a class="headerlink" href="#36" title="Permanent link">&para;</a></h3>
<ul>
<li>subscribe</li>
<li>unsubscribe</li>
<li>publish</li>
<li>psusbscribe: 订阅与给定模式匹配的所有频道</li>
<li>punsubscribe</li>
</ul>
<p>redis可能无法很好处理客户端失联、消息积压等</p>
<h3 id="37">3.7 其他命令<a class="headerlink" href="#37" title="Permanent link">&para;</a></h3>
<h5 id="371">3.7.1 排序<a class="headerlink" href="#371" title="Permanent link">&para;</a></h5>
<p>redis sort 能对多种数据类型排序</p>
<h5 id="372-redis">3.7.2 基本的 redis 事务<a class="headerlink" href="#372-redis" title="Permanent link">&para;</a></h5>
<p>redis基本事务(basic transaction):让一个客户端在不被其他客户端打断的情况下执行多个命令，和关系数据库可以执行过程中回滚的事务不同，
redis 里被 multi 命令和exec 命令包围的所有命令会一个接一个执行，直到所有命令执行完毕，redis 才会处理其他客户端命令。</p>
<p>redis 事务在 python client 上使用 pipeline 实现，客户端自动使用multi和exec，客户端会存储事务包含的多个命令，一次性把所有命令发送给redis。
移除竞争条件；减少通信次数提升性能。redis 原子操作指的是在读取或者修改数据的时候，其他客户端不能读取或修改相同数据。</p>
<h5 id="373">3.7.3 键过期时间<a class="headerlink" href="#373" title="Permanent link">&para;</a></h5>
<p>自动删除过期键减少内存使用，</p>
<ul>
<li>persist: 移除键的过期时间</li>
<li>ttl: 查看给定键离过期时间还有多少秒</li>
<li>expire: 将给定键的过期时间设置为给定 unix 时间戳</li>
<li>pttl: 查看给定键过期时间还有多少毫秒</li>
<li>pexpire: 给定键指定毫秒后过期</li>
<li>pexpireat</li>
</ul>
<h1 id="4">4. 数据安全与性能保障<a class="headerlink" href="#4" title="Permanent link">&para;</a></h1>
<h3 id="41">4.1 持久化选项<a class="headerlink" href="#41" title="Permanent link">&para;</a></h3>
<ul>
<li>快照(snapshotting):讲某一时刻所有数据都写入硬盘。如果系统崩溃，可能丢失最近一次快照生成之后更改的所有数据。</li>
<li>追加文件(AOF, append-only file): 执行写命令时，被执行的写命令复制到硬盘里</li>
</ul>
<h3 id="42">4.2 复制<a class="headerlink" href="#42" title="Permanent link">&para;</a></h3>
<p>主从模式，redis 不支持主-主复制
slave of 命令</p>
<p>从服务器在进行同步时，会清空自己的所有数据，并被替换为主服务器发来的数据。
使用复制和AOF持久化，增强redis 对系统崩溃的抵抗能力。</p>
<h3 id="43">4.3 处理系统故障<a class="headerlink" href="#43" title="Permanent link">&para;</a></h3>
<p>验证快找文件和AOF文件：</p>
<ul>
<li>redis-check-aof</li>
<li>redis-check-dump</li>
</ul>
<p>更换故障主服务器</p>
<h3 id="44-redis">4.4 Redis 事务<a class="headerlink" href="#44-redis" title="Permanent link">&para;</a></h3>
<p>pipeline: 一次性发送多个命令，然后等待所有回复出现</p>
<p>redis使用了乐观锁的方式：redis为了尽可能减少客户端的等待时间，并不会在执行WATCH命令的时候对数据加锁。
相反，redis只会在数据已经被其他客户端抢先修改了的情况下，通知执行了watch 命令的客户端，这种做法被称为乐观锁。
关系数据库实际执行的加锁操作则被称为悲观锁(pessimistic locking)。</p>
<p>乐观锁使客户端不用等待第一个取得锁的客户端，只需要在自己的事务执行失败的时候重试就可以了。</p>
<h3 id="45">4.5 非事务型流水线<a class="headerlink" href="#45" title="Permanent link">&para;</a></h3>
<p>除了使用批量命令，还可以使用非事务型流水线。
python客户端 redispy 在 pipe = conn.pipeline(False) 传入False
参数，可以让客户端会像执行事务那样收集用户要执行的所有命令，但是不会使用 MULTI 和 EXEC 包裹这些命令。</p>
<h3 id="46">4.6 关于性能方面的注意事项<a class="headerlink" href="#46" title="Permanent link">&para;</a></h3>
<p>一个不使用流水线的python客户端性能大概只有 redis-benchmark 的 50%~60%。
大部分客户端库都提供了连接池。</p>
<h1 id="5-redis">5. 使用 Redis 构建支持程序<a class="headerlink" href="#5-redis" title="Permanent link">&para;</a></h1>
<h3 id="51-redis">5.1 使用 Redis 来记录日志<a class="headerlink" href="#51-redis" title="Permanent link">&para;</a></h3>
<p>linux/unix中两种常见记录日志的方法：</p>
<ul>
<li>日志记录到文件。</li>
<li>syslog</li>
</ul>
<h3 id="52">5.2 计数器和统计数据<a class="headerlink" href="#52" title="Permanent link">&para;</a></h3>
<p>实现时间序列计数器</p>
<p>最好用现成的 Graphite</p>
<h3 id="53-ip">5.3 查找 IP 所属城市以及国家<a class="headerlink" href="#53-ip" title="Permanent link">&para;</a></h3>
<p>预先载入 ip 数据和地址数据到redis，存储的时候把点分十进制格式的 ip 转成一个整数分值。
把数据转换成整数并搭配有序集合进行操作。</p>
<div class="highlight"><pre><span></span><code>def ip_to_score(ip_address):
    score = 0
    for v in ip_address.split(&#39;.&#39;):
        score = score * 256 + int(v, 10)
    return score
</code></pre></div>
<h3 id="54">5.4 服务的发现与配置<a class="headerlink" href="#54" title="Permanent link">&para;</a></h3>
<p>将配置存储在redis里，编写应用程序获取配置</p>
<h1 id="6-redis">6. 使用 Redis 构建应用程序组件<a class="headerlink" href="#6-redis" title="Permanent link">&para;</a></h1>
<h3 id="61">6.1 自动补全<a class="headerlink" href="#61" title="Permanent link">&para;</a></h3>
<ul>
<li>主动补全最近联系人: 通过list 存储元素（元素数量较小），然后在 python 代码里进行 filter</li>
<li>通讯录自动补全：使用zset，所有分值置为0，通过插入带查找元素的前缀和后缀元素的方式确定待查找元素的范围</li>
</ul>
<h3 id="62">6.2 分布式锁<a class="headerlink" href="#62" title="Permanent link">&para;</a></h3>
<p>(乐观锁)
redis WATCH 实现的是乐观锁（只有通知功能）。由WATCH, MULTI EXEC
组成的事务并不具有可扩展性，程序在尝试完成一个事务的时候，可能会因为事务执行失败反复重试。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">acquire_lock</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">acquire_timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">acquire_timeout</span>
    <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">setnx</span><span class="p">(</span><span class="s1">&#39;lock:&#39;</span> <span class="o">+</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>  <span class="c1"># setnx 如果没有key就会设置</span>
            <span class="k">return</span> <span class="n">identifier</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">release_lock</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
    <span class="n">pipe</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">pipeline</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">lockname</span> <span class="o">=</span> <span class="s1">&#39;lock:&#39;</span> <span class="o">+</span> <span class="n">lockname</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pipe</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">lockname</span><span class="p">)</span>    <span class="c1"># 检查进程是否仍然持有锁</span>
            <span class="k">if</span> <span class="n">pipe</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">locname</span><span class="p">)</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">:</span>
                <span class="n">pipe</span><span class="o">.</span><span class="n">multi</span><span class="p">()</span>   <span class="c1"># 开始释放锁</span>
                <span class="n">pipe</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">lockname</span><span class="p">)</span>
                <span class="n">pipe</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">pipe</span><span class="o">.</span><span class="n">unwatch</span><span class="p">()</span>
            <span class="k">break</span>
        <span class="k">except</span> <span class="n">redis</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">WatchError</span><span class="p">:</span>  <span class="c1"># 有其他客户端修改了锁，重试</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># 进程已经失去了锁</span>
</code></pre></div>
<p>细粒度的锁能够提升程序性能，但是过细粒度可能导致死锁问题。</p>
<p>上边的实现在持有者崩溃的时候不会自动释放，会导致锁一直处于被获取的状态，下边加上超时功能。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">acquire_lock_with_timeout</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">acquire_timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">lock_timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
    <span class="n">lockname</span> <span class="o">=</span> <span class="s1">&#39;lock:&#39;</span> <span class="o">+</span> <span class="n">lockname</span>
    <span class="n">lock_timeout</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">lock_timeout</span><span class="p">))</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">acquire_timeout</span>
    <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">setnx</span><span class="p">(</span><span class="n">lockname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">lockname</span><span class="p">,</span> <span class="n">lock_timeout</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">identifier</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">conn</span><span class="o">.</span><span class="n">ttl</span><span class="p">(</span><span class="n">lockname</span><span class="p">):</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">lockname</span><span class="p">,</span> <span class="n">lock_timeout</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.001</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
<h3 id="63">6.3 计数信号量<a class="headerlink" href="#63" title="Permanent link">&para;</a></h3>
<p>限制一个资源最多同时被多少个进程访问，限定能够同时使用的资源数量。
和锁不同的是，锁通常在客户端获取锁失败的时候等待，而当客户端获取信号量失败的时候，客户端通常会立即返回失败结果。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">acquire_semaphore</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
    <span class="n">now</span>  <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">pipeline</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">pipeline</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zremrangebyscore</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="s1">&#39;-inf&#39;</span><span class="p">,</span> <span class="n">now</span><span class="o">-</span><span class="n">timeout</span><span class="p">)</span> <span class="c1"># 清理过期的信号量持有者</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span>   <span class="c1"># 尝试获取信号量</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zrank</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>  <span class="c1"># 检查是否成功获取了信号量</span>
        <span class="k">return</span> <span class="n">identifier</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">zrem</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>  <span class="c1"># 获取信号量失败后，删除之前添加的标识符</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">release_semphore</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">zrem</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
</code></pre></div>
<p>这个信号量简单快速，但是有个问题，就是它假设每个进程访问到的系统事件都是相同的,
每当锁或者信号量因为系统始终的细微不同导致锁的获取结果出现剧烈变化时，这个锁或者信号量就是不公平的。(unfair)</p>
<p>如何实现公平信号量：给信号量实现添加一个计数器以及一个有序集合。计数器通过持续执行自增操作，创建出一个类似于计时器的机制，
确保最先对计数器执行自增操作的客户端能够获得信号量。另外，为了满足『最先对计数器执行自增操作的客户端能够获得信号量』这一要求，
程序会将计数器生成的值用作分值，存储到一个『信号量拥有者』有序集合里，然后通过检查客户端生成的标志符在有序集合里的排名判断客户端是否取得了信号量。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">acquire_faire_lock_semaphore</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span>  <span class="n">limit</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
    <span class="n">czset</span> <span class="o">=</span> <span class="n">semname</span> <span class="o">+</span> <span class="s1">&#39;:owner&#39;</span>
    <span class="n">ctr</span> <span class="o">=</span> <span class="n">semname</span> <span class="o">+</span> <span class="s1">&#39;:counter&#39;</span>

    <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">pipeline</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">pipeline</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zremrangebyscore</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="s1">&#39;-inf&#39;</span><span class="p">,</span> <span class="n">now</span> <span class="o">-</span> <span class="n">timeout</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zinterstore</span><span class="p">(</span><span class="n">czset</span><span class="p">,</span> <span class="p">{</span><span class="n">czeset</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">semname</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>    <span class="c1"># 删除超时的信号量</span>

    <span class="n">pipeline</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">pipeline</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span>   <span class="c1"># NOTE :注意这个客户端不是StrictRedis，参数顺序不一样</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="n">czset</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>

    <span class="n">pipeline</span><span class="o">.</span><span class="n">zrank</span><span class="p">(</span><span class="n">czset</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>  <span class="c1"># 通过检查排名来判断客户端是否取得信号量</span>
        <span class="k">return</span> <span class="n">identifier</span>

    <span class="n">pipeline</span><span class="o">.</span><span class="n">zrem</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>  <span class="c1"># 未能获取信号量清理数据</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zrem</span><span class="p">(</span><span class="n">czset</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">release_faire_semaphore</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
    <span class="n">pipeline</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">pipeline</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zrem</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">zrem</span><span class="p">(</span><span class="n">semname</span> <span class="o">+</span> <span class="s1">&#39;:owner&#39;</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># 返回True表示信号量已经释放，False表示想要释放的信号量因为超时被删除了</span>
</code></pre></div>
<p>这里注意如果是频繁大量使用信号量的情况下，32位计数器的值大约2小时就会溢出一次，最好切到64位平台。
这里实现依然需要控制各个主机的差距系统事件在1 秒之内。</p>
<p>对信号量进行刷新，防止过期：</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">refresh_fair_semaphore</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()):</span>  <span class="c1"># 更新客户端持有的信号量</span>
        <span class="n">release_fair_semaphore</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># 告知调用者已经失去了信号量</span>
    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># 客户端仍持有信号量</span>
</code></pre></div>
<p>前面介绍的实现会出现不正确的竞争条件。如果AB俩进程都在尝试获取一个信号量时，即使A首先对计数器执行了自增操作，
但是B只要能抢先把自己的标识符添加到有序集合里，并检查标志符在有序集合中的排名，B就可以成功获取信号量。
之后当A也将自己的标志符添加到有序集合里时，并检查标志符在有序集合中的排名时，A将『偷走』B已经取得的信号量，
而B只有在尝试释放或者刷新的时候才能发现。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">acquire_semaphore_with_lock</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="n">acquire_lock</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">acquire_timeout</span><span class="o">=</span><span class="mf">.01</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">identifier</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">acquire_fair_semaphore</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">release_lock</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">semname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
</code></pre></div>
<p>信号量可以用来限制同时可运行的 api 调用数量，针对数据库的并发请求等。</p>
<h3 id="64">6.4 任务队列<a class="headerlink" href="#64" title="Permanent link">&para;</a></h3>
<p>FIFO 队列：借助 redis list 的 blpop rpush 来实现一个队列
延迟任务：借助 redis zset 实现</p>
<h3 id="65">6.5 消息拉取<a class="headerlink" href="#65" title="Permanent link">&para;</a></h3>
<p>使用 Redis 的 PUBLISH SUBSCRIBE 的问题时，如果客户端因为某些原因无法一直在线，消息推送可能会出问题。
可以采用拉取模式</p>
<h3 id="66-redis">6.6 redis 文件分发<a class="headerlink" href="#66-redis" title="Permanent link">&para;</a></h3>
<p>当NFS，Samba、文件复制、mapreduce 不适合的时候。</p>
<h1 id="7">7. 基于搜索的应用程序<a class="headerlink" href="#7" title="Permanent link">&para;</a></h1>
<h3 id="71-redis">7.1 使用 redis 进行搜索<a class="headerlink" href="#71-redis" title="Permanent link">&para;</a></h3>
<p>首先需要根据文档生成倒排索引。从文档提取单词的过程称为语法分析(parsing)和标记化(tokenize)。
标记化的一个常见附加步骤是移除内容中的非用词(stop word)，在文档中出现频繁但是却没有提供相应信息量的单词。
然后存储到 redis 的 set 里，每个集合记录该单词出现的所有文档。</p>
<p>关联度：搜索程序在获得多个文档之后，还需要根据每个文档的重要性排序(SORT 命令)。一种方式是看哪个文档更新事件最接近当前时间。</p>
<h3 id="72">7.2 有序索引<a class="headerlink" href="#72" title="Permanent link">&para;</a></h3>
<p>使用zset 实现多个分值的复合排序操作。ZINTERSTORE</p>
<p>如何使用有序集合进行非数值排序：把字符串通过一种方式转成数值类型，书中给了一种方式（最多6个字符，受限于浮点数范围）
这样就能基于字符串前缀实现搜索，使用 zrangebyscore 命令查找长度不超过6个字符的前缀。</p>
<h3 id="73">7.3 广告定向<a class="headerlink" href="#73" title="Permanent link">&para;</a></h3>
<p>广告服务器：每当用户访问一个带有广告的web页面的时候，web服务器和用户的web浏览器都会向远程服务器发送请求以获取广告，
广告服务器会接受各种信息，并根据这些信息找出能够通过点击、浏览、动作获取最大经济收益的广告。</p>
<p>web 页面广告通常有三类型： 按展示次数(cost per view), 按点击数(cost per click)，按动作执行次数(cost per action)
动作执行次数又称按购买次数（cost per acquisitoin）。按展示次数计费的广告又称为CPM 广告或千次计费(cost per mille)广告。</p>
<h3 id="74">7.4 职位搜索<a class="headerlink" href="#74" title="Permanent link">&para;</a></h3>
<p>首先把每个职位需要的技能数量添加到有序集合里，首先计算出求职者对于每个职位的得分，然后使用胜任这些职位所需的总分减去求职者在这些职位上的得分，
在最后得出的结果有序集合里，分值为0 的职位就是求职者能够胜任的职位。</p>
<h1 id="8">8. 构建简单的社交网站<a class="headerlink" href="#8" title="Permanent link">&para;</a></h1>
<p>本章构建一个和 twitter 后端类似的社交网站</p>
<h3 id="81">8.1 用户和状态<a class="headerlink" href="#81" title="Permanent link">&para;</a></h3>
<p>使用 hash 存储用户的信息， name &lsquo;user:id&rsquo;  {&lsquo;id&rsquo;: login, id, name, folllowers, following, posts, signup}
hash 存储状态消息： &lsquo;status:id&rsquo; {&lsquo;id&rsquo;: message, posted, id, uid, login}</p>
<h3 id="82">8.2 最常见的状态消息列表，用户主页时间线<a class="headerlink" href="#82" title="Permanent link">&para;</a></h3>
<p>用户登录的情况下访问twitter 时，主页看到的是自己的主页时间线。时间线是一个列表，由用户以及用户正在关注的人发布的状态组成。
使用zset 实现时间线。 zset  home:12234 {&lsquo;status_id&rsquo;: timestamp} 个人时间线 zset  profile:12234 {&lsquo;status_id&rsquo;: timestamp} 个</p>
<h3 id="83">8.3 关注者列表和正在关注列表<a class="headerlink" href="#83" title="Permanent link">&para;</a></h3>
<p>使用 zset 存储关注者和被关注。 zset followers:id  {id: timestamp}
当关注或者停止关注的时候，需要对两个关注的zset 和用户的关注数量、被关注数量进行更新。
如果用户执行的是关注操作，还需要从被关注的用户时间线里，复制一些状态消息 id 到执行关注操作的主页时间线里，
从而使得用户在关注另一个用户之后， 可以立即看见被关注用户所发的状态消息。</p>
<h3 id="84">8.4 状态消息的发布与删除<a class="headerlink" href="#84" title="Permanent link">&para;</a></h3>
<p>对于关注者比较少的用户，可以直接把用户发送的状态同步到每个关注者的时间线里，但是如果关注者很多(大V)， 需要使用延迟方式。
这种问题涉及到 feed 流系统中的『推拉模型』，到底是选择推还是拉取。经常是推拉结合。</p>
<p>删除消息：删除该消息在状态消息的散列(hash status:id)，更新已经发送的消息数量。然后清理用户时间线残留的消息 id</p>
<h3 id="85-api">8.5 流API<a class="headerlink" href="#85-api" title="Permanent link">&para;</a></h3>
<p>有时候我们想知道网站正在发生的事情，比如每个小时发布了多少条状态，最热门的恩主题是什么等。可以通过专门执行一些调用，
或者函数内部记录这些信息。
还有一种方法就是构建一些函数来广播(broadcast)事件(event)，然后由负责进行数据分析的事件监听器(event listener)接受处理这些事件。</p>
<ul>
<li>公开哪些事件？</li>
<li>是否访问限制?何种方式</li>
<li>提供哪些过滤选项</li>
</ul>
<h1 id="9">9. 降低内存占用<a class="headerlink" href="#9" title="Permanent link">&para;</a></h1>
<h3 id="91">9.1 使用短结构<a class="headerlink" href="#91" title="Permanent link">&para;</a></h3>
<p>redis为列表、集合、散列和有序集合提供了可以配置选项，让 redis 以更节约控件的的方式存储长度较短的结构（短结构）
在列表(双链表)、散列(散列表)和有序集合(散列表+跳跃表)长度较短或者体积较小的时候，redis 可以选择使用 压缩列表(ziplist)的紧凑存储方式存储这些结构。</p>
<p>list-max-zip-entries 512
list-max-zip-value 64</p>
<p>可以用 DEBUG OBJECT 来观察</p>
<p>当整数包含的成员都能解释成十进制整数，并且又处于平台的有符号整数范围之内，集合使用『整数集合(intset)』，有有序数组方式存储集合。</p>
<p>尽量减少键的长度</p>
<h3 id="92">9.2 分片结构<a class="headerlink" href="#92" title="Permanent link">&para;</a></h3>
<p>分片(sharding)，本质上就是基于简单的规则吧数据划分更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上。</p>
<ul>
<li>对列表分片。11 章介绍 lua 脚本实现方案</li>
<li>对有序集合分片。无法想普通的有序集合那样快速实现 zrange 等，分片作用不大</li>
</ul>
<p>对于 namespace:id 形式的值可以考虑存储到分片散列里。降低内存占用</p>
<h3 id="93">9.3 打包存储二进制位和字节<a class="headerlink" href="#93" title="Permanent link">&para;</a></h3>
<p>存储的是简短并且长度固定的连续 id，可以将数据打包存储在字符串键里边。</p>
<h1 id="10-redis">10. 扩展 redis<a class="headerlink" href="#10-redis" title="Permanent link">&para;</a></h1>
<h3 id="101">10.1 扩展读性能<a class="headerlink" href="#101" title="Permanent link">&para;</a></h3>
<p>回顾下提升性能的几个途径：</p>
<ul>
<li>短结构</li>
<li>合适的数据结构</li>
<li>大体积对象压缩(lz4/gzip/bzip2)</li>
<li>流水线和连接池</li>
</ul>
<p>为一个 redis 主服务器配置多个从服务器，但只对主服务器写入。主从同步问题</p>
<h3 id="102">10.2 扩展写性能和内存容量<a class="headerlink" href="#102" title="Permanent link">&para;</a></h3>
<p>通过预先分片写入不同的服务器</p>
<h3 id="103">10.3 扩展复杂的查询<a class="headerlink" href="#103" title="Permanent link">&para;</a></h3>
<p>对每个分片进行查询(并行)，最后统一聚合查询结果并且排序输出。</p>
<h1 id="11-redis-lua">11. Redis Lua 脚本编程<a class="headerlink" href="#11-redis-lua" title="Permanent link">&para;</a></h1>
<h3 id="111-c">11.1 在不编写C代码的情况下添加功能<a class="headerlink" href="#111-c" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">script_load</span><span class="p">(</span><span class="n">script</span><span class="p">):</span>
    <span class="n">sha</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[],</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">force_eval</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_eval</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sha</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">sha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SCRIPT&quot;</span><span class="p">,</span> <span class="s2">&quot;LOAD&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">parse</span><span class="o">=</span><span class="s2">&quot;LOAD&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;EVALSHA&quot;</span><span class="p">,</span> <span class="n">sha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">keys</span> <span class="o">+</span> <span class="n">args</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">redis</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ResponseError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="o">.</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;NOSCRIPT&quot;</span><span class="p">):</span>
                    <span class="k">raise</span>

        <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;EVAL&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">keys</span> <span class="o">+</span> <span class="n">args</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">call</span>
</code></pre></div>
<h3 id="112-lua">11.2 使用 Lua 重写锁和信号量<a class="headerlink" href="#112-lua" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">acquire_lock_with_timeout</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">acquire_timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">lock_timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">identifier</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
    <span class="n">lockname</span> <span class="o">=</span> <span class="s1">&#39;lock:&#39;</span> <span class="o">+</span> <span class="n">lockname</span>
    <span class="n">lock_timeout</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">lock_timeout</span><span class="p">))</span>

    <span class="n">acquired</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">acquire_timeout</span>
    <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">acquired</span><span class="p">:</span>
        <span class="n">acquired</span> <span class="o">=</span> <span class="n">acquire_lock_with_timeout_lua</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">[</span><span class="n">lockname</span><span class="p">],</span> <span class="p">[</span><span class="n">lock_timeout</span><span class="p">,</span> <span class="n">identifier</span><span class="p">])</span> <span class="o">==</span> <span class="s1">&#39;OK&#39;</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.001</span> <span class="o">*</span> <span class="p">(</span><span class="ow">not</span> <span class="n">acquired</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">acquired</span> <span class="ow">and</span> <span class="n">identifier</span>

<span class="c1"># 注意 lua 下标 1 开始</span>
<span class="n">acquire_lock_with_timeout_lua</span> <span class="o">=</span> <span class="n">script_load</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">if redis.call(&#39;exists&#39;, KEYS[1]) == 0 then</span>
<span class="s1">    return redis.call(&#39;setex&#39;, KEYS[1], unpack(ARGV))</span>
<span class="s1">end</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">release_lock</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
    <span class="n">lockname</span> <span class="o">=</span> <span class="s1">&#39;lock&#39;</span> <span class="o">+</span> <span class="n">lockname</span>
    <span class="k">return</span> <span class="n">release_lock_lua</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">[</span><span class="n">lockname</span><span class="p">],</span> <span class="p">[</span><span class="n">identifier</span><span class="p">])</span>

<span class="n">release_lock_lua</span><span class="o">=</span><span class="n">script_load</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then</span>
<span class="s1">    return redis.call(&#39;del&#39;, KEYS[1]) or true</span>
<span class="s1">end</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
</code></pre></div>
<h3 id="113-watchmultiexec">11.3 移除 WATCH/MULTI/EXEC 事务<a class="headerlink" href="#113-watchmultiexec" title="Permanent link">&para;</a></h3>
<p>注意：运行在redis内部的lua脚本只能访问位于 lua 脚本或者 redis 数据库之内的数据， 锁或WATCH/MULTI/EXEC 事务没有这个限制</p>
<h3 id="114-lua">11.4 使用 Lua 对列表进行分片<a class="headerlink" href="#114-lua" title="Permanent link">&para;</a></h3>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2a1c317c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.3a4b43e5.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
    
  </body>
</html>